

Compiled 9 Solidity files successfully (evm target: london).
 ·-----------------------------------------|--------------------------------|--------------------------------·
 |  Solc version: 0.8.18                   ·  Optimizer enabled: true       ·  Runs: 200                     │
 ··········································|································|·································
 |  Contract Name                          ·  Deployed size (KiB) (change)  ·  Initcode size (KiB) (change)  │
 ··········································|································|·································
 |  ABDKMath64x64                          ·                 0.084 (0.000)  ·                 0.138 (0.000)  │
 ··········································|································|·································
 |  Address                                ·                 0.084 (0.000)  ·                 0.138 (0.000)  │
 ··········································|································|·································
 |  Address                                ·                 0.084 (0.000)  ·                 0.118 (0.000)  │
 ··········································|································|·································
 |  AddressQueueStorage                    ·                 5.473 (0.000)  ·                 5.600 (0.000)  │
 ··········································|································|·································
 |  AddressSetStorage                      ·                 3.764 (0.000)  ·                 3.891 (0.000)  │
 ··········································|································|·································
 |  AddressUpgradeable                     ·                 0.084 (0.000)  ·                 0.138 (0.000)  │
 ··········································|································|·································
 |  Treasury                          ·                 6.060 (0.000)  ·                 6.728 (0.000)  │
 ··········································|································|·································
 |  Clones                                 ·                 0.084 (0.000)  ·                 0.118 (0.000)  │
 ··········································|································|·································
 |  console                                ·                 0.084 (0.000)  ·                 0.138 (0.000)  │
 ··········································|································|·································
 |  Constants                              ·                 1.587 (0.000)  ·                 1.644 (0.000)  │
 ··········································|································|·································
 |  Create2                                ·                 0.084 (0.000)  ·                 0.138 (0.000)  │
 ··········································|································|·································
 |  FundRouter                            ·                9.111 (+0.181)  ·                9.779 (+0.181)  │
 ··········································|································|·································
 |  Directory                              ·                12.019 (0.000)  ·                12.401 (0.000)  │
 ··········································|································|·································
 |  ECDSA                                  ·                 0.084 (0.000)  ·                 0.138 (0.000)  │
 ··········································|································|·································
 |  ERC1967Proxy                           ·                 0.683 (0.000)  ·                 1.788 (0.000)  │
 ··········································|································|·································
 |  ERC20                                  ·                 2.256 (0.000)  ·                 3.007 (0.000)  │
 ··········································|································|·································
 |  ERC20                                  ·                 2.080 (0.000)  ·                 2.818 (0.000)  │
 ··········································|································|·································
 |  ERC20Upgradeable                       ·                 2.087 (0.000)  ·                 2.118 (0.000)  │
 ··········································|································|·································
 |  Errors                                 ·                 0.062 (0.000)  ·                 0.090 (0.000)  │
 ··········································|································|·································
 |  Math                                   ·                 0.084 (0.000)  ·                 0.138 (0.000)  │
 ··········································|································|·································
 |  MathUpgradeable                        ·                 0.084 (0.000)  ·                 0.138 (0.000)  │
 ··········································|································|·································
 |  MerkleProof                            ·                 0.084 (0.000)  ·                 0.138 (0.000)  │
 ··········································|································|·································
 |  MerkleProof                            ·                 0.084 (0.000)  ·                 0.118 (0.000)  │
 ··········································|································|·································
 |  MockERC20                              ·                 3.080 (0.000)  ·                 4.189 (0.000)  │
 ··········································|································|·································
 |  MockMinipool                           ·                 1.762 (0.000)  ·                 1.793 (0.000)  │
 ··········································|································|·································
 |  MockPriceFetcher                       ·                 3.317 (0.000)  ·                 3.693 (0.000)  │
 ··········································|································|·································
 |  MockRETHOracle                         ·                 0.168 (0.000)  ·                 0.202 (0.000)  │
 ··········································|································|·································
 |  MockRocketNodeManager                  ·                 0.845 (0.000)  ·                 0.876 (0.000)  │
 ··········································|································|·································
 |  MockRocketNodeStaking                  ·                 0.823 (0.000)  ·                 0.854 (0.000)  │
 ··········································|································|·································
 |  MockRocketStorage                      ·                 0.447 (0.000)  ·                 0.479 (0.000)  │
 ··········································|································|·································
 |  MockSanctions                          ·                 0.259 (0.000)  ·                 0.290 (0.000)  │
 ··········································|································|·································
 |  MockUniswapV3Pool                      ·                 0.251 (0.000)  ·                 0.299 (0.000)  │
 ··········································|································|·································
 |  OperatorDistributor                    ·                17.333 (0.000)  ·                18.001 (0.000)  │
 ··········································|································|·································
 |  PenaltyTest                            ·                 0.893 (0.000)  ·                 1.013 (0.000)  │
 ··········································|································|·································
 |  PriceFetcher                           ·                 5.415 (0.000)  ·                 5.792 (0.000)  │
 ··········································|································|·································
 |  ProtocolMath                           ·                 0.145 (0.000)  ·                 0.199 (0.000)  │
 ··········································|································|·································
 |  ProtocolMathTest                       ·                 3.812 (0.000)  ·                 3.843 (0.000)  │
 ··········································|································|·································
 |  RevertOnTransfer                       ·                 0.062 (0.000)  ·                 0.090 (0.000)  │
 ··········································|································|·································
 |  RocketAuctionManager                   ·                 9.606 (0.000)  ·                 9.733 (0.000)  │
 ··········································|································|·································
 |  RocketClaimDAO                         ·                 5.758 (0.000)  ·                 5.933 (0.000)  │
 ··········································|································|·································
 |  RocketClaimDAOOld                      ·                 1.747 (0.000)  ·                 1.874 (0.000)  │
 ··········································|································|·································
 |  RocketDAONodeTrusted                   ·                14.063 (0.000)  ·                14.189 (0.000)  │
 ··········································|································|·································
 |  RocketDAONodeTrustedActions            ·                15.712 (0.000)  ·                15.839 (0.000)  │
 ··········································|································|·································
 |  RocketDAONodeTrustedProposals          ·                13.729 (0.000)  ·                13.856 (0.000)  │
 ··········································|································|·································
 |  RocketDAONodeTrustedSettingsMembers    ·                 4.065 (0.000)  ·                 6.323 (0.000)  │
 ··········································|································|·································
 |  RocketDAONodeTrustedSettingsMinipool   ·                 4.693 (0.000)  ·                 7.697 (0.000)  │
 ··········································|································|·································
 |  RocketDAONodeTrustedSettingsProposals  ·                 3.547 (0.000)  ·                 5.380 (0.000)  │
 ··········································|································|·································
 |  RocketDAONodeTrustedSettingsRewards    ·                 3.658 (0.000)  ·                 5.496 (0.000)  │
 ··········································|································|·································
 |  RocketDAONodeTrustedUpgrade            ·                 8.198 (0.000)  ·                 8.325 (0.000)  │
 ··········································|································|·································
 |  RocketDAOProposal                      ·                15.165 (0.000)  ·                15.292 (0.000)  │
 ··········································|································|·································
 |  RocketDAOProtocol                      ·                 9.442 (0.000)  ·                 9.626 (0.000)  │
 ··········································|································|·································
 |  RocketDAOProtocolActions               ·                 0.133 (0.000)  ·                 0.259 (0.000)  │
 ··········································|································|·································
 |  RocketDAOProtocolOld                   ·                 7.081 (0.000)  ·                 7.252 (0.000)  │
 ··········································|································|·································
 |  RocketDAOProtocolProposal              ·                13.939 (0.000)  ·                14.123 (0.000)  │
 ··········································|································|·································
 |  RocketDAOProtocolProposals             ·                 8.564 (0.000)  ·                 8.742 (0.000)  │
 ··········································|································|·································
 |  RocketDAOProtocolProposalsOld          ·                 5.455 (0.000)  ·                 5.626 (0.000)  │
 ··········································|································|·································
 |  RocketDAOProtocolSettingsAuction       ·                 3.899 (0.000)  ·                 7.021 (0.000)  │
 ··········································|································|·································
 |  RocketDAOProtocolSettingsAuctionOld    ·                 4.826 (0.000)  ·                 7.148 (0.000)  │
 ··········································|································|·································
 |  RocketDAOProtocolSettingsDeposit       ·                 3.289 (0.000)  ·                 5.711 (0.000)  │
 ··········································|································|·································
 |  RocketDAOProtocolSettingsDepositOld    ·                 4.835 (0.000)  ·                 7.111 (0.000)  │
 ··········································|································|·································
 |  RocketDAOProtocolSettingsInflation     ·                 3.617 (0.000)  ·                 6.447 (0.000)  │
 ··········································|································|·································
 |  RocketDAOProtocolSettingsInflationOld  ·                 4.987 (0.000)  ·                 7.620 (0.000)  │
 ··········································|································|·································
 |  RocketDAOProtocolSettingsMinipool      ·                 4.090 (0.000)  ·                 6.826 (0.000)  │
 ··········································|································|·································
 |  RocketDAOProtocolSettingsMinipoolOld   ·                 3.808 (0.000)  ·                 6.195 (0.000)  │
 ··········································|································|·································
 |  RocketDAOProtocolSettingsNetwork       ·                 4.729 (0.000)  ·                 8.436 (0.000)  │
 ··········································|································|·································
 |  RocketDAOProtocolSettingsNetworkOld    ·                 5.688 (0.000)  ·                 8.634 (0.000)  │
 ··········································|································|·································
 |  RocketDAOProtocolSettingsNode          ·                 4.761 (0.000)  ·                 7.017 (0.000)  │
 ··········································|································|·································
 |  RocketDAOProtocolSettingsProposals     ·                 5.081 (0.000)  ·                 9.012 (0.000)  │
 ··········································|································|·································
 |  RocketDAOProtocolSettingsRewards       ·                 4.130 (0.000)  ·                 5.581 (0.000)  │
 ··········································|································|·································
 |  RocketDAOProtocolSettingsRewardsOld    ·                 6.308 (0.000)  ·                 9.497 (0.000)  │
 ··········································|································|·································
 |  RocketDAOProtocolSettingsSecurity      ·                 3.632 (0.000)  ·                 6.269 (0.000)  │
 ··········································|································|·································
 |  RocketDAOProtocolVerifier              ·                14.703 (0.000)  ·                14.887 (0.000)  │
 ··········································|································|·································
 |  RocketDAOSecurity                      ·                 3.036 (0.000)  ·                 3.211 (0.000)  │
 ··········································|································|·································
 |  RocketDAOSecurityActions               ·                 5.402 (0.000)  ·                 5.577 (0.000)  │
 ··········································|································|·································
 |  RocketDAOSecurityProposals             ·                 7.802 (0.000)  ·                 7.977 (0.000)  │
 ··········································|································|·································
 |  RocketDepositPool                      ·                11.981 (0.000)  ·                12.680 (0.000)  │
 ··········································|································|·································
 |  RocketMerkleDistributorMainnet         ·                 5.598 (0.000)  ·                 6.150 (0.000)  │
 ··········································|································|·································
 |  RocketMerkleDistributorMainnetOld      ·                 6.665 (0.000)  ·                 7.266 (0.000)  │
 ··········································|································|·································
 |  RocketMinipoolBase                     ·                 5.166 (0.000)  ·                 5.275 (0.000)  │
 ··········································|································|·································
 |  RocketMinipoolBondReducer              ·                 8.620 (0.000)  ·                 8.794 (0.000)  │
 ··········································|································|·································
 |  RocketMinipoolDelegate                 ·                22.281 (0.000)  ·                22.352 (0.000)  │
 ··········································|································|·································
 |  RocketMinipoolFactory                  ·                 1.701 (0.000)  ·                 1.828 (0.000)  │
 ··········································|································|·································
 |  RocketMinipoolManager                  ·                17.215 (0.000)  ·                17.398 (0.000)  │
 ··········································|································|·································
 |  RocketMinipoolManagerOld               ·                18.969 (0.000)  ·                19.148 (0.000)  │
 ··········································|································|·································
 |  RocketMinipoolPenalty                  ·                 1.612 (0.000)  ·                 1.735 (0.000)  │
 ··········································|································|·································
 |  RocketMinipoolQueue                    ·                 8.325 (0.000)  ·                 8.452 (0.000)  │
 ··········································|································|·································
 |  RocketNetworkBalances                  ·                 4.307 (0.000)  ·                 4.481 (0.000)  │
 ··········································|································|·································
 |  RocketNetworkBalancesOld               ·                 4.487 (0.000)  ·                 4.662 (0.000)  │
 ··········································|································|·································
 |  RocketNetworkFees                      ·                 2.666 (0.000)  ·                 2.793 (0.000)  │
 ··········································|································|·································
 |  RocketNetworkPenalties                 ·                 5.103 (0.000)  ·                 5.229 (0.000)  │
 ··········································|································|·································
 |  RocketNetworkPrices                    ·                 4.352 (0.000)  ·                 4.597 (0.000)  │
 ··········································|································|·································
 |  RocketNetworkPricesOld                 ·                 4.894 (0.000)  ·                 5.403 (0.000)  │
 ··········································|································|·································
 |  RocketNetworkSnapshots                 ·                 3.251 (0.000)  ·                 3.426 (0.000)  │
 ··········································|································|·································
 |  RocketNetworkVoting                    ·                 5.673 (0.000)  ·                 5.895 (0.000)  │
 ··········································|································|·································
 |  RocketNodeDeposit                      ·                 9.896 (0.000)  ·                10.080 (0.000)  │
 ··········································|································|·································
 |  RocketNodeDepositLEB4                  ·                10.012 (0.000)  ·                10.195 (0.000)  │
 ··········································|································|·································
 |  RocketNodeDepositOld                   ·                10.092 (0.000)  ·                10.219 (0.000)  │
 ··········································|································|·································
 |  RocketNodeDistributor                  ·                 0.281 (0.000)  ·                 0.497 (0.000)  │
 ··········································|································|·································
 |  RocketNodeDistributorDelegate          ·                 2.280 (0.000)  ·                 2.563 (0.000)  │
 ··········································|································|·································
 |  RocketNodeDistributorFactory           ·                 1.813 (0.000)  ·                 1.940 (0.000)  │
 ··········································|································|·································
 |  RocketNodeManager                      ·                16.276 (0.000)  ·                16.460 (0.000)  │
 ··········································|································|·································
 |  RocketNodeManagerOld                   ·                16.766 (0.000)  ·                16.945 (0.000)  │
 ··········································|································|·································
 |  RocketNodeStaking                      ·                12.812 (0.000)  ·                13.084 (0.000)  │
 ··········································|································|·································
 |  RocketNodeStakingOld                   ·                10.746 (0.000)  ·                10.873 (0.000)  │
 ··········································|································|·································
 |  RocketpoolEncoder                      ·                 0.084 (0.000)  ·                 0.138 (0.000)  │
 ··········································|································|·································
 |  RocketRewardsPool                      ·                 9.004 (0.000)  ·                 9.182 (0.000)  │
 ··········································|································|·································
 |  RocketRewardsPoolOld                   ·                 9.004 (0.000)  ·                 9.182 (0.000)  │
 ··········································|································|·································
 |  RocketSmoothingPool                    ·                 1.809 (0.000)  ·                 1.979 (0.000)  │
 ··········································|································|·································
 |  RocketStorage                          ·                 8.549 (0.000)  ·                 8.610 (0.000)  │
 ··········································|································|·································
 |  RocketTokenDummyRPL                    ·                 3.498 (0.000)  ·                 4.205 (0.000)  │
 ··········································|································|·································
 |  RocketTokenRETH                        ·                 8.134 (0.000)  ·                 8.563 (0.000)  │
 ··········································|································|·································
 |  RocketTokenRPL                         ·                 7.549 (0.000)  ·                 8.465 (0.000)  │
 ··········································|································|·································
 |  RocketUpgradeOneDotThree               ·                14.247 (0.000)  ·                14.453 (0.000)  │
 ··········································|································|·································
 |  RocketVault                            ·                 7.322 (0.000)  ·                 7.449 (0.000)  │
 ··········································|································|·································
 |  RPLVault                               ·                14.042 (0.000)  ·                14.710 (0.000)  │
 ··········································|································|·································
 |  SafeCast                               ·                 0.084 (0.000)  ·                 0.138 (0.000)  │
 ··········································|································|·································
 |  SafeCast                               ·                 0.084 (0.000)  ·                 0.118 (0.000)  │
 ··········································|································|·································
 |  SafeERC20                              ·                 0.084 (0.000)  ·                 0.118 (0.000)  │
 ··········································|································|·································
 |  SafeERC20                              ·                 0.084 (0.000)  ·                 0.138 (0.000)  │
 ··········································|································|·································
 |  SafeERC20Upgradeable                   ·                 0.084 (0.000)  ·                 0.138 (0.000)  │
 ··········································|································|·································
 |  SafeMath                               ·                 0.084 (0.000)  ·                 0.138 (0.000)  │
 ··········································|································|·································
 |  SafeMath                               ·                 0.084 (0.000)  ·                 0.118 (0.000)  │
 ··········································|································|·································
 |  SignedMath                             ·                 0.084 (0.000)  ·                 0.138 (0.000)  │
 ··········································|································|·································
 |  SignedMathUpgradeable                  ·                 0.084 (0.000)  ·                 0.138 (0.000)  │
 ··········································|································|·································
 |  SignedSafeMath                         ·                 0.084 (0.000)  ·                 0.118 (0.000)  │
 ··········································|································|·································
 |  SnapshotTest                           ·                 1.693 (0.000)  ·                 2.281 (0.000)  │
 ··········································|································|·································
 |  StorageSlot                            ·                 0.084 (0.000)  ·                 0.138 (0.000)  │
 ··········································|································|·································
 |  StorageSlotUpgradeable                 ·                 0.084 (0.000)  ·                 0.138 (0.000)  │
 ··········································|································|·································
 |  Strings                                ·                 0.084 (0.000)  ·                 0.138 (0.000)  │
 ··········································|································|·································
 |  StringsUpgradeable                     ·                 0.084 (0.000)  ·                 0.138 (0.000)  │
 ··········································|································|·································
 |  NodeAccount                       ·                 8.680 (0.000)  ·                 9.067 (0.000)  │
 ··········································|································|·································
 |  NodeAccountFactory                ·                 8.435 (0.000)  ·                 8.822 (0.000)  │
 ··········································|································|·································
 |  WETH                                   ·                 2.941 (0.000)  ·                 3.440 (0.000)  │
 ··········································|································|·································
 |  WETHVault                              ·                18.690 (0.000)  ·                19.358 (0.000)  │
 ··········································|································|·································
 |  Whitelist                              ·                 8.301 (0.000)  ·                 8.688 (0.000)  │
 ··········································|································|·································
 |  WhitelistV2                            ·                 8.331 (0.000)  ·                 8.719 (0.000)  │
 ··········································|································|·································
 |  NodeSetOperatorRewardDistributor                       ·                13.221 (0.000)  ·                13.608 (0.000)  │
 ·-----------------------------------------|--------------------------------|--------------------------------·

  Validator Account Factory
Duplicate definition of SanctionViolation (SanctionViolation(address,address), SanctionViolation(address))
directory value rocket network penality
0x9a9f2ccfde556a7e9ff0848998aa4a0cfd8863ae
directory value rocket network price
0xcbeaf3bde82155f56486fb5a1072cb8baaf547cc
Duplicate definition of SanctionViolation (SanctionViolation(address,address), SanctionViolation(address))
Duplicate definition of SanctionViolation (SanctionViolation(address,address), SanctionViolation(address))
AssertionError: expected 22 to equal 12
nonce 0 predicted 12
directory value rocket network penality
0x9a9f2ccfde556a7e9ff0848998aa4a0cfd8863ae
directory value rocket network price
0xcbeaf3bde82155f56486fb5a1072cb8baaf547cc
Duplicate definition of SanctionViolation (SanctionViolation(address,address), SanctionViolation(address))
Duplicate definition of SanctionViolation (SanctionViolation(address,address), SanctionViolation(address))
Duplicate definition of SanctionViolation (SanctionViolation(address,address), SanctionViolation(address))
Duplicate definition of SanctionViolation (SanctionViolation(address,address), SanctionViolation(address))
Duplicate definition of SanctionViolation (SanctionViolation(address,address), SanctionViolation(address))
Duplicate definition of SanctionViolation (SanctionViolation(address,address), SanctionViolation(address))
before calling getPriceFetcherAddress
0xd30bf3219a0416602be8d482e0396ef332b0494e
B
price 51127333500000000000
fallback od initial
8000000000000000000
sendEthToDistributors.A
sendEthToDistributors.B
sendEthToDistributors.C
sendEthToDistributors.D
sendEthToDistributors.E
sendEthToDistributors.E1
sendEthToDistributors.E2
sendEthToDistributors.E3

    1) Run the MOAT (Mother Of all Atomic Transactions)
before calling getPriceFetcherAddress
0xd30bf3219a0416602be8d482e0396ef332b0494e
B
price 51127333500000000000
fallback od initial
8000000000000000000
sendEthToDistributors.A
sendEthToDistributors.B
sendEthToDistributors.C
sendEthToDistributors.D
sendEthToDistributors.E
sendEthToDistributors.E1
sendEthToDistributors.E2
sendEthToDistributors.E3

    2) fails - not whitelisted
before calling getPriceFetcherAddress
0xd30bf3219a0416602be8d482e0396ef332b0494e
B
price 51127333500000000000
    ✔ fails - bad predicted address
before calling getPriceFetcherAddress
0xd30bf3219a0416602be8d482e0396ef332b0494e
B
price 51127333500000000000
    ✔ fails - forget to lock 1 eth
before calling getPriceFetcherAddress
0xd30bf3219a0416602be8d482e0396ef332b0494e
B
price 51127333500000000000
    ✔ fails - no liquidity for given bond


  3 passing (8s)
  2 failing

  1) Validator Account Factory
       Run the MOAT (Mother Of all Atomic Transactions):
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="Transaction reverted: contract call run out of gas and made the transaction revert", method="estimateGas", transaction={"from":"0x1CBd3b2770909D4e10f157cABC84C7264073C9Ec","to":"0x10e38eE9dd4C549b61400Fc19347D00eD3edAfC4","value":{"type":"BigNumber","hex":"0x6f05b59d3b200000"},"accessList":null}, error={"stackTrace":[{"type":2,"address":{"type":"Buffer","data":[16,227,142,233,221,76,84,155,97,64,15,193,147,71,208,14,211,237,175,196]}},{"type":0,"sourceReference":{"function":"<receive>","contract":"OperatorDistributor","sourceName":"contracts/Operator/OperatorDistributor.sol","sourceContent":"// SPDX-License-Identifier: GPL v3\npragma solidity 0.8.17;\n\nimport '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';\n\nimport '../UpgradeableBase.sol';\nimport '../Whitelist/Whitelist.sol';\nimport '../FundRouter.sol';\nimport '../PriceFetcher.sol';\nimport '../Tokens/WETHVault.sol';\n\nimport '../Utils/Constants.sol';\nimport '../Utils/Errors.sol';\n\nimport '../Interfaces/IWETH.sol';\nimport '../Interfaces/RocketPool/IRocketStorage.sol';\nimport '../Interfaces/RocketPool/IMinipool.sol';\nimport '../Interfaces/RocketPool/IRocketNodeManager.sol';\nimport '../Interfaces/RocketPool/IRocketNodeStaking.sol';\n\ncontract OperatorDistributor is UpgradeableBase, Errors {\n    event MinipoolCreated(address indexed _minipoolAddress, address indexed _nodeAddress);\n    event MinipoolDestroyed(address indexed _minipoolAddress, address indexed _nodeAddress);\n    event WarningNoMiniPoolsToHarvest();\n    event WarningMinipoolNotStaking(address indexed _minipoolAddress, MinipoolStatus indexed _status);\n\n    using Math for uint256;\n\n    // The total amount of Ether (ETH) funded or allocated by the contract.\n    // This variable keeps track of the ETH resources managed within this contract,\n    uint256 public fundedEth;\n\n    // The total amount of Rocket Pool tokens (RPL) funded or allocated by the contract.\n    // This field is used to track the RPL token balance managed by the contract,\n    uint256 public fundedRpl;\n\n    address[] public minipoolAddresses;\n\n    uint256 public nextMinipoolHavestIndex;\n    uint256 public targetStakeRatio;\n\n    uint256 public numMinipoolsProcessedPerInterval;\n\n    uint256 public requiredLEBStaked;\n\n    mapping(address => uint256) public minipoolIndexMap;\n    mapping(address => uint256) public minipoolAmountFundedEth;\n    mapping(address => uint256) public minipoolAmountFundedRpl;\n\n    mapping(address => address[]) public nodeOperatorOwnedMinipools;\n    mapping(address => uint256) public nodeOperatorEthStaked;\n\n    constructor() initializer {}\n\n    /**\n     * @notice Initializes the contract with the provided storage address.\n     * @dev This function should only be called once, during contract creation or proxy initialization.\n     * It overrides the `initialize` function from a parent contract.\n     * @param _directory The address of the storage contract.\n     */\n    function initialize(address _directory) public override initializer {\n        super.initialize(_directory);\n        targetStakeRatio = 1.5e18; // 150%\n        numMinipoolsProcessedPerInterval = 1;\n\n        // defaulting these to 8eth to only allow LEB8 minipools\n        requiredLEBStaked = 8 ether;\n    }\n\n    /**\n     * @notice Receives incoming Ether and adds it to the queued balance.\n     * @dev This is the fallback function that is called when Ether is sent directly to the contract.\n     */\n    receive() external payable {\n        address payable dp = _directory.getDepositPoolAddress();\n        console.log('fallback od initial');\n        console.log(address(this).balance);\n\n        if (msg.sender != dp) {\n            (bool success, ) = dp.call{value: msg.value}('');\n            require(success, 'low level call failed in od');\n            FundRouter(dp).sendEthToDistributors();\n        }\n\n        console.log('fallback od final');\n        console.log(address(this).balance);\n    }\n\n    function _rebalanceLiquidity() internal nonReentrant {\n        address payable dp = _directory.getDepositPoolAddress();\n        (bool success, ) = dp.call{value: address(this).balance}('');\n        require(success, 'low level call failed in od');\n        FundRouter(dp).sendEthToDistributors();\n\n        IERC20 rpl = IERC20(_directory.getRPLAddress());\n        SafeERC20.safeTransfer(rpl, dp, rpl.balanceOf(address(this)));\n        FundRouter(dp).sendRplToDistributors();\n    }\n\n    /// @notice Gets the total ETH value locked inside the protocol, including inside of validators, the OperatorDistributor,\n    /// and this contract.\n    /// @dev This function sums up the balance of this contract with the amount of funded ETH across all minipools.\n    /// Ensure that all sources of ETH (like the OperatorDistributor) are properly accounted for in the calculation.\n    /// @return The total amount of Ether locked inside the protocol.\n    function getTvlEth() public view returns (uint) {\n        return address(this).balance + fundedEth;\n    }\n\n    /// @notice Gets the total RPL value locked inside the protocol, including inside of validators, the OperatorDistributor,\n    /// and this contract.\n    /// @dev This function calculates the total RPL by summing up the balance of RPL tokens of this contract\n    /// with the amount of funded RPL across all minipools. It retrieves the RPL token address from the `_directory` contract.\n    /// Ensure that all sources of RPL (like the OperatorDistributor) are accurately accounted for.\n    /// @return The total amount of RPL tokens locked inside the protocol.\n    function getTvlRpl() public view returns (uint) {\n        return RocketTokenRPLInterface(_directory.getRPLAddress()).balanceOf(address(this)) + fundedRpl;\n    }\n\n    /**\n     * @notice Removes a minipool address from the tracked list when a node operator exits.\n     * @dev This function efficiently reorders the minipool addresses array and updates the index map.\n     * It then resets the funded amount of ETH and RPL tokens for the removed minipool.\n     * Should only be called by authorized protocol actors or admin.\n     * @param _address The address of the minipool to be removed.\n     *\n     * Emits a `MinipoolDestroyed` event upon successful removal.\n     */ function removeMinipoolAddress(address _address) public onlyProtocolOrAdmin {\n        uint index = minipoolIndexMap[_address] - 1;\n        require(index < minipoolAddresses.length, 'Address not found.');\n\n        // Move the last address into the spot located by index\n        address lastAddress = minipoolAddresses[minipoolAddresses.length - 1];\n        minipoolAddresses[index] = lastAddress;\n        minipoolIndexMap[lastAddress] = index;\n\n        // Remove the last address\n        minipoolAddresses.pop();\n        delete minipoolIndexMap[_address];\n\n        // Set amount funded to 0 since it's being returned to DP\n        minipoolAmountFundedEth[_address] = 0;\n        minipoolAmountFundedRpl[_address] = 0;\n\n        emit MinipoolDestroyed(_address, IMinipool(_address).getNodeAddress());\n    }\n\n    /**\n     * @notice Removes a node operator and all associated minipools.\n     * @dev Iterates through all minipools owned by the node operator and removes them.\n     * This action cannot be reversed, so it should be executed with caution.\n     * Only authorized protocol actors or admin can call this function.\n     * @param _address The address of the node operator to be removed.\n     */\n    function removeNodeOperator(address _address) external onlyProtocolOrAdmin {\n        // remove all minipools owned by node operator\n        address[] memory minipools = nodeOperatorOwnedMinipools[_address];\n        for (uint i = 0; i < minipools.length; i++) {\n            removeMinipoolAddress(minipools[i]);\n        }\n        delete nodeOperatorOwnedMinipools[_address];\n    }\n\n    /**\n     * @notice Stakes the minimum required RPL tokens on behalf of a node.\n     * @dev This function first fetches the node's minimum RPL stake requirement,\n     * approves the Node Staking contract to spend the RPL, and then stakes the RPL for the node.\n     * It assumes that the contract already holds enough RPL tokens for the staking process.\n     * @param _nodeAddress The address of the node for which RPL should be staked.\n     */\n    function _stakeRPLFor(address _nodeAddress) internal {\n        IRocketNodeStaking nodeStaking = IRocketNodeStaking(getDirectory().getRocketNodeStakingAddress());\n        uint256 minimumRplStake = IRocketNodeStaking(getDirectory().getRocketNodeStakingAddress())\n            .getNodeMinimumRPLStake(_nodeAddress);\n\n        fundedRpl += minimumRplStake;\n\n        // approve the node staking contract to spend the RPL\n        RocketTokenRPLInterface rpl = RocketTokenRPLInterface(_directory.getRPLAddress());\n        require(rpl.approve(getDirectory().getRocketNodeStakingAddress(), minimumRplStake));\n\n        // update amount funded rpl\n        minipoolAmountFundedRpl[_nodeAddress] = minimumRplStake;\n\n        nodeStaking.stakeRPLFor(_nodeAddress, minimumRplStake);\n    }\n\n    /**\n     * @notice Prepares a node for minipool creation by setting up necessary staking and validations.\n     * @dev This function first validates the node's withdrawal address, then calculates the required amount of\n     * RPL to stake based on the number of validators associated with the node, and performs a top-up.\n     * Only the protocol or admin can call this function.\n     * @param _NodeAccount The address of the validator account belonging to the Node Operator\n     */\n    function provisionLiquiditiesForMinipoolCreation(\n        address _nodeOperator,\n        address _NodeAccount,\n        uint256 _bond\n    ) external onlyProtocolOrAdmin {\n        _rebalanceLiquidity();\n        require(_bond == requiredLEBStaked, 'OperatorDistributor: Bad _bond amount, should be `requiredLEBStaked`');\n        fundedEth += _bond;\n        nodeOperatorEthStaked[_nodeOperator] += _bond;\n\n        // by default this bonds 150% of stake according to max stake defined here: https://docs.rocketpool.net/guides/node/create-validator#staking-rpl\n        // performTopUp(_NodeAccount, nodeOperatorEthStaked[_nodeOperator]);\n        (bool success, bytes memory data) = _NodeAccount.call{value: _bond}('');\n        if (!success) {\n            revert LowLevelEthTransfer(success, data);\n        }\n    }\n\n    /**\n     * @notice Tops up the node operator's RPL stake if it falls below the target stake ratio.\n     * @dev This function checks the current staking ratio of the node (calculated as ETH staked times its price in RPL\n     * divided by RPL staked). If the ratio is below a predefined target, it calculates the necessary RPL amount to\n     * bring the stake ratio back to the target. Then, the function either stakes the required RPL or stakes\n     * the remaining RPL balance if it's not enough.\n     * @param _NodeAccount The address of the node.\n     * @param _ethStaked The amount of ETH currently staked by the node operator.\n     */\n    function performTopUp(address _NodeAccount, uint256 _ethStaked) public onlyProtocolOrAdmin {\n        uint256 rplStaked = IRocketNodeStaking(_directory.getRocketNodeStakingAddress()).getNodeRPLStake(\n            _NodeAccount\n        );\n        uint256 ethPriceInRpl = PriceFetcher(getDirectory().getPriceFetcherAddress()).getPrice();\n\n        uint256 stakeRatio = rplStaked == 0 ? 1e18 : (_ethStaked * ethPriceInRpl * 1e18) / rplStaked;\n        if (stakeRatio < targetStakeRatio) {\n            uint256 minuend = ((_ethStaked * ethPriceInRpl) / targetStakeRatio);\n            uint256 requiredStakeRpl = minuend < rplStaked ? 0 : minuend - rplStaked;\n            // Make sure the contract has enough RPL to stake\n            uint256 currentRplBalance = RocketTokenRPLInterface(_directory.getRPLAddress()).balanceOf(address(this));\n            if (currentRplBalance >= requiredStakeRpl) {\n                if (requiredStakeRpl == 0) {\n                    return;\n                }\n                // stakeRPLOnBehalfOf\n                // transfer RPL to deposit pool\n                RocketTokenRPLInterface(_directory.getRPLAddress()).transfer(\n                    _directory.getDepositPoolAddress(),\n                    requiredStakeRpl\n                );\n                FundRouter(_directory.getDepositPoolAddress()).stakeRPLFor(_NodeAccount, requiredStakeRpl);\n            } else {\n                if (currentRplBalance == 0) {\n                    return;\n                }\n                // stake what we have\n                RocketTokenRPLInterface(_directory.getRPLAddress()).transfer(\n                    _directory.getDepositPoolAddress(),\n                    currentRplBalance\n                );\n                FundRouter(_directory.getDepositPoolAddress()).stakeRPLFor(_NodeAccount, currentRplBalance);\n            }\n        }\n    }\n\n    function performTopDown(address _nodeAddress, uint256 _ethStaked) public onlyProtocolOrAdmin {\n        uint256 rplStaked = IRocketNodeStaking(_directory.getRocketNodeStakingAddress()).getNodeRPLStake(_nodeAddress);\n        uint256 ethPriceInRpl = PriceFetcher(getDirectory().getPriceFetcherAddress()).getPrice();\n\n        uint256 stakeRatio = rplStaked == 0 ? 1e18 : (_ethStaked * ethPriceInRpl * 1e18) / rplStaked;\n        if (stakeRatio > targetStakeRatio) {\n            uint256 maxRplStake = (_ethStaked * ethPriceInRpl) / targetStakeRatio;\n            uint256 excessRpl = rplStaked > maxRplStake ? rplStaked - maxRplStake : 0;\n\n            if (excessRpl > 0) {\n                fundedRpl -= excessRpl;\n                FundRouter(_directory.getDepositPoolAddress()).unstakeRpl(_nodeAddress, excessRpl);\n\n                // Update the amount of RPL funded by the node\n                minipoolAmountFundedRpl[_nodeAddress] -= excessRpl;\n            }\n        }\n    }\n\n    /**\n     * @notice Calculates the amount of RPL needed to top up the node operator's stake to the target stake ratio.\n     * @dev This view function checks the current staking ratio of the node (calculated as ETH staked times its price in RPL\n     * divided by RPL staked). If the ratio is below a predefined target, it returns the necessary RPL amount to\n     * bring the stake ratio back to the target.\n     * @param _existingRplStake Prior crap staked\n     * @param _ethStaked The amount of ETH currently staked by the node operator.\n     * @return requiredStakeRpl The amount of RPL required to top up to the target stake ratio.\n     */\n    function calculateRequiredRplTopUp(\n        uint256 _existingRplStake,\n        uint256 _ethStaked\n    ) public view returns (uint256 requiredStakeRpl) {\n        console.log('before calling getPriceFetcherAddress');\n        console.logAddress(getDirectory().getPriceFetcherAddress());\n        console.log('B');\n        uint256 ethPriceInRpl = PriceFetcher(getDirectory().getPriceFetcherAddress()).getPrice();\n        console.log('price', ethPriceInRpl);\n        uint256 stakeRatio = _existingRplStake == 0 ? 1e18 : (_ethStaked * ethPriceInRpl * 1e18) / _existingRplStake;\n        if (stakeRatio < targetStakeRatio) {\n            uint256 minuend = ((_ethStaked * ethPriceInRpl) / targetStakeRatio);\n            requiredStakeRpl = minuend < _existingRplStake ? 0 : minuend - _existingRplStake;\n        } else {\n            requiredStakeRpl = 0;\n        }\n        return requiredStakeRpl;\n    }\n\n    /**\n     * @notice Calculates the amount of RPL that can be withdrawn from the node operator's stake without falling below the target stake ratio.\n     * @dev This view function checks the current staking ratio of the node (calculated as ETH staked times its price in RPL\n     * divided by RPL staked). If the ratio is above a predefined target, it returns the maximum RPL amount that can be withdrawn\n     * while still maintaining at least the target stake ratio.\n     * @param _existingRplStake The amount of RPL currently staked by the node operator.\n     * @param _ethStaked The amount of ETH currently staked by the node operator.\n     * @return withdrawableStakeRpl The maximum amount of RPL that can be withdrawn while maintaining the target stake ratio.\n     */\n    function calculateRequiredRplTopDown(\n        uint256 _existingRplStake,\n        uint256 _ethStaked\n    ) public view returns (uint256 withdrawableStakeRpl) {\n        uint256 ethPriceInRpl = PriceFetcher(getDirectory().getPriceFetcherAddress()).getPrice();\n\n        uint256 stakeRatio = _existingRplStake == 0 ? 1e18 : (_ethStaked * ethPriceInRpl * 1e18) / _existingRplStake;\n        if (stakeRatio > targetStakeRatio) {\n            uint256 maxRplStake = (_ethStaked * ethPriceInRpl) / targetStakeRatio;\n            withdrawableStakeRpl = _existingRplStake > maxRplStake ? _existingRplStake - maxRplStake : 0;\n        } else {\n            withdrawableStakeRpl = 0;\n        }\n        return withdrawableStakeRpl;\n    }\n\n    /**\n     * @notice Processes rewards for a predefined number of minipools. This function is meant to be called during\n     * the creation of new intervals. It serves to withdraw rewards from minipools and to top up the RPL stake.\n     * @dev The function first checks if there are any minipools to process. If there aren't, it emits a warning event\n     * and exits. Otherwise, it calls the internal function _processNextMinipool() for a certain number of times defined\n     * by numMinipoolsProcessedPerInterval.\n     */\n    function processNextMinipool() external onlyProtocol {\n        if (minipoolAddresses.length == 0) {\n            emit WarningNoMiniPoolsToHarvest();\n            return;\n        }\n\n        for (uint i = 0; i < numMinipoolsProcessedPerInterval; i++) {\n            _processNextMinipool();\n        }\n    }\n\n    function OnMinipoolCreated(address newMinipoolAddress, address nodeAddress, uint256 bond) external {\n        if (!_directory.hasRole(Constants.CORE_PROTOCOL_ROLE, msg.sender)) {\n            revert BadRole(Constants.CORE_PROTOCOL_ROLE, msg.sender);\n        }\n\n        // register minipool with node operator\n        Whitelist whitelist = Whitelist(getDirectory().getWhitelistAddress());\n        whitelist.registerNewValidator(nodeAddress);\n\n        // new minipool owned by node operator\n        nodeOperatorOwnedMinipools[nodeAddress].push(newMinipoolAddress);\n\n        // add minipool to minipoolAddresses\n        minipoolAddresses.push(newMinipoolAddress);\n        minipoolIndexMap[newMinipoolAddress] = minipoolAddresses.length;\n\n        emit MinipoolCreated(newMinipoolAddress, nodeAddress);\n\n        // updated amount funded eth\n        minipoolAmountFundedEth[newMinipoolAddress] = bond;\n    }\n\n    /**\n     * @dev Processes a single minipool by performing RPL top-up and distributing balance if certain conditions are met.\n     */\n    function _processNextMinipool() internal {\n        uint256 index = nextMinipoolHavestIndex % minipoolAddresses.length;\n        IMinipool minipool = IMinipool(minipoolAddresses[index]);\n\n        if (minipool.getStatus() != MinipoolStatus.Staking) {\n            emit WarningMinipoolNotStaking(address(minipool), minipool.getStatus());\n            return;\n        }\n\n        // process top up\n        address nodeAddress = minipool.getNodeAddress();\n\n        uint256 ethStaked = nodeOperatorEthStaked[nodeAddress];\n\n        performTopUp(nodeAddress, ethStaked);\n        performTopDown(nodeAddress, ethStaked);\n\n        nextMinipoolHavestIndex = index + 1;\n\n        uint256 balance = minipool.getNodeDepositBalance();\n        minipool.distributeBalance(balance >= 8 ether);\n    }\n\n    /**\n     * @notice Set the number of minipools to be processed per interval.\n     * @dev This function can only be called by the contract's admin.\n     * Adjusting this parameter allows the admin to control and optimize the load\n     * on the network for each interval, especially in scenarios with a large number of minipools.\n     * @param _numMinipoolsProcessedPerInterval The new number of minipools to process per interval.\n     */\n    function setNumMinipoolsProcessedPerInterval(uint256 _numMinipoolsProcessedPerInterval) external onlyAdmin {\n        numMinipoolsProcessedPerInterval = _numMinipoolsProcessedPerInterval;\n    }\n\n    function setBondRequirements(uint256 _requiredLEBStaked) external onlyAdmin {\n        requiredLEBStaked = _requiredLEBStaked;\n    }\n\n    function onNodeMinipoolDestroy(address _nodeOperator, uint256 _bond) external onlyProtocol {\n        fundedEth -= _bond;\n        nodeOperatorEthStaked[_nodeOperator] -= _bond;\n    }\n\n    /**\n     * @notice Retrieves the list of minipool addresses managed by the contract.\n     * @dev This function provides a way to fetch all the current minipool addresses in memory.\n     * Useful for off-chain services or frontend interfaces that need to display or interact\n     * with the various minipools.\n     * @return A list of addresses corresponding to the minipools.\n     */\n    function getMinipoolAddresses() external view returns (address[] memory) {\n        return minipoolAddresses;\n    }\n\n    function transferWEthToVault(uint256 _amount) external returns (uint256) {\n        address vault = _directory.getWETHVaultAddress();\n        require(msg.sender == vault, 'caller must be vault');\n        address weth = _directory.getWETHAddress();\n\n        // Check if there's enough WETH in the contract\n        uint256 wethBalance = IWETH(weth).balanceOf(address(this));\n        if (wethBalance >= _amount) {\n            IWETH(weth).deposit{value: _amount}();\n            SafeERC20.safeTransfer(IERC20(weth), vault, _amount);\n            return _amount;\n        } else {\n            return 0;\n        }\n    }\n\n    function transferRplToVault(uint256 _amount) external returns (uint256) {\n        address vault = _directory.getRPLVaultAddress();\n        require(msg.sender == vault, 'caller must be vault');\n\n        // Check if there's enough RPL in the contract\n        address rpl = IERC4626Upgradeable(vault).asset();\n        uint256 rplBalance = IERC20(rpl).balanceOf(address(this));\n        if (rplBalance >= _amount) {\n            SafeERC20.safeTransfer(IERC20(rpl), vault, _amount);\n            return _amount;\n        } else {\n            return 0;\n        }\n    }\n}\n","line":82,"range":[3167,3206]},"functionType":3},{"type":2,"address":{"type":"Buffer","data":[38,46,43,80,33,150,32,34,108,95,181,149,100,50,168,143,255,217,75,167]}},{"type":0,"sourceReference":{"function":"sendEthToDistributors","contract":"FundRouter","sourceName":"contracts/FundRouter.sol","sourceContent":"// SPDX-License-Identifier: GPL v3\npragma solidity 0.8.17;\n\nimport '@openzeppelin/contracts/utils/Strings.sol';\n\nimport './UpgradeableBase.sol';\nimport './Operator/OperatorDistributor.sol';\nimport './Operator/NodeSetOperatorRewardDistributor.sol';\nimport './Interfaces/RocketPool/IRocketNodeStaking.sol';\nimport './Tokens/WETHVault.sol';\nimport './Tokens/RPLVault.sol';\n\nimport './Interfaces/IWETH.sol';\nimport './Utils/Constants.sol';\n\n/// @custom:security-contact info@nodeoperator.org\n/// @notice Immutable deposit pool which holds deposits and provides a minimum source of liquidity for depositors.\n/// ETH + RPL intakes from token mints and validator yields and sends to respective ERC4246 vaults.\ncontract FundRouter is UpgradeableBase {\n    constructor() initializer {}\n\n    /// @dev Initializes the FundRouter contract with the specified directory address.\n    /// @param directoryAddress The address of the directory contract.\n    function initialize(address directoryAddress) public virtual override initializer {\n        super.initialize(directoryAddress);\n    }\n\n    ///--------\n    /// GETTERS\n    ///--------\n\n    /// @notice Retrieves the total ETH and WETH value locked inside this deposit pool.\n    /// @dev This function calculates and returns the combined value of ETH and WETH held by the deposit pool.\n    ///      It sums the ETH balance of this contract and the WETH balance from the WETH contract.\n    /// @return The total value in ETH and WETH locked in the deposit pool.\n    function getTvlEth() public view returns (uint) {\n        return address(this).balance + IWETH(_directory.getWETHAddress()).balanceOf(address(this));\n    }\n\n    /// @notice Retrieves the total RPL value locked inside this deposit pool.\n    /// @dev This function calculates and returns the total amount of RPL tokens held by the deposit pool.\n    /// @return The total value in RPL locked in the deposit pool.\n    function getTvlRpl() public view returns (uint) {\n        return RocketTokenRPLInterface(_directory.getRPLAddress()).balanceOf(address(this));\n    }\n\n    ///--------\n    /// ACTIONS\n    ///--------\n\n    /// @notice Unstakes a specified amount of RPL tokens.\n    /// @dev This function allows an administrator to unstake a specified amount of RPL tokens from the Rocket Node Staking contract.\n    /// @param _excessRpl The amount of RPL tokens to unstake.\n    /// @dev The tokens will be withdrawn from the Rocket Node Staking contract.\n    function unstakeRpl(address _nodeAddress, uint256 _excessRpl) external onlyAdmin {\n        IRocketNodeStaking(getDirectory().getRocketNodeStakingAddress()).withdrawRPL(_nodeAddress, _excessRpl);\n    }\n\n    /// @notice Stakes a specified amount of RPL tokens on behalf of a node operator.\n    /// @dev This function allows the protocol or an administrator to stake a specified amount of RPL tokens on behalf of a node operator\n    ///      using the Rocket Node Staking contract.\n    /// @param _nodeAddress The address of the node operator on whose behalf the RPL tokens are being staked.\n    /// @param _amount The amount of RPL tokens to stake.\n    /// @dev This function ensures that the specified amount of RPL tokens is approved and then staked for the given node operator.\n    function stakeRPLFor(address _nodeAddress, uint256 _amount) external onlyProtocolOrAdmin {\n        SafeERC20.safeApprove(\n            RocketTokenRPLInterface(_directory.getRPLAddress()),\n            _directory.getRocketNodeStakingAddress(),\n            0\n        );\n        SafeERC20.safeApprove(\n            RocketTokenRPLInterface(_directory.getRPLAddress()),\n            _directory.getRocketNodeStakingAddress(),\n            _amount\n        );\n        IRocketNodeStaking(_directory.getRocketNodeStakingAddress()).stakeRPLFor(_nodeAddress, _amount);\n    }\n\n    function sendEthToDistributors() public {\n        console.log('sendEthToDistributors.A');\n        // Convert entire WETH balance of this contract to ETH\n        IWETH WETH = IWETH(_directory.getWETHAddress());\n        uint256 wethBalance = WETH.balanceOf(address(this));\n        WETH.withdraw(wethBalance);\n        console.log('sendEthToDistributors.B');\n\n        // Initialize the vault and operator distributor addresses\n        WETHVault vweth = WETHVault(getDirectory().getWETHVaultAddress());\n        address payable operatorDistributor = payable(getDirectory().getOperatorDistributorAddress());\n        console.log('sendEthToDistributors.C');\n\n        // Calculate required capital and total balance\n        uint256 requiredCapital = vweth.getRequiredCollateral();\n        uint256 ethBalance = address(this).balance;\n        console.log('sendEthToDistributors.D');\n\n        if (ethBalance >= requiredCapital) {\n            console.log('sendEthToDistributors.E');\n\n            // Send required capital in WETH to vault and surplus ETH to operator distributor\n            WETH.deposit{value: requiredCapital}();\n            console.log('sendEthToDistributors.E1');\n\n            SafeERC20.safeTransfer(WETH, address(vweth), requiredCapital);\n            console.log('sendEthToDistributors.E2');\n\n            uint256 surplus = ethBalance - requiredCapital;\n            console.log('sendEthToDistributors.E3');\n\n            operatorDistributor.transfer(surplus);\n            console.log('sendEthToDistributors.F');\n        } else {\n            console.log('sendEthToDistributors.G');\n\n            // If not enough ETH balance, convert the shortfall in WETH back to ETH and send it\n            uint256 shortfall = requiredCapital - ethBalance;\n            WETH.deposit{value: shortfall}();\n            SafeERC20.safeTransfer(IERC20(address(WETH)), address(vweth), requiredCapital);\n            console.log('sendEthToDistributors.H');\n        }\n        console.log('sendEthToDistributors.I');\n    }\n\n    function sendRplToDistributors() public {\n        console.log('sendRplToDistributors.A');\n\n        // Initialize the RPLVault and the Operator Distributor addresses\n        RPLVault vrpl = RPLVault(getDirectory().getRPLVaultAddress());\n        address operatorDistributor = getDirectory().getOperatorDistributorAddress();\n        RocketTokenRPLInterface RPL = RocketTokenRPLInterface(_directory.getRPLAddress());\n        console.log('sendRplToDistributors.B');\n\n        // Fetch the required capital in RPL and the total RPL balance of the contract\n        uint256 requiredCapital = vrpl.getRequiredCollateral();\n        uint256 totalBalance = RPL.balanceOf(address(this));\n        console.log('sendRplToDistributors.C');\n\n        // Determine the amount to send to the RPLVault\n        uint256 toRplVault = (totalBalance >= requiredCapital) ? requiredCapital : totalBalance;\n        console.log('sendRplToDistributors.D');\n\n        // Transfer RPL to the RPLVault\n        if (toRplVault > 0) {\n            console.log('sendRplToDistributors.E');\n\n            SafeERC20.safeTransfer(IERC20(address(RPL)), address(vrpl), toRplVault);\n        }\n\n        // Transfer any surplus RPL to the Operator Distributor\n        if (totalBalance > toRplVault) {\n            console.log('sendRplToDistributors.F');\n\n            SafeERC20.safeTransfer(IERC20(address(RPL)), operatorDistributor, totalBalance - toRplVault);\n        }\n        console.log('sendRplToDistributors.G');\n    }\n\n    /// @notice Receive hook for ETH deposits.\n    /// @dev This function allows the contract to receive ETH deposits sent to its address.\n    ///      It is used as a fallback function to accept incoming ETH transfers.\n    receive() external payable {}\n}\n","line":110,"range":[5213,5250]},"functionType":1},{"type":2,"address":{"type":"Buffer","data":[16,227,142,233,221,76,84,155,97,64,15,193,147,71,208,14,211,237,175,196]}},{"type":0,"sourceReference":{"function":"<receive>","contract":"OperatorDistributor","sourceName":"contracts/Operator/OperatorDistributor.sol","sourceContent":"// SPDX-License-Identifier: GPL v3\npragma solidity 0.8.17;\n\nimport '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';\n\nimport '../UpgradeableBase.sol';\nimport '../Whitelist/Whitelist.sol';\nimport '../FundRouter.sol';\nimport '../PriceFetcher.sol';\nimport '../Tokens/WETHVault.sol';\n\nimport '../Utils/Constants.sol';\nimport '../Utils/Errors.sol';\n\nimport '../Interfaces/IWETH.sol';\nimport '../Interfaces/RocketPool/IRocketStorage.sol';\nimport '../Interfaces/RocketPool/IMinipool.sol';\nimport '../Interfaces/RocketPool/IRocketNodeManager.sol';\nimport '../Interfaces/RocketPool/IRocketNodeStaking.sol';\n\ncontract OperatorDistributor is UpgradeableBase, Errors {\n    event MinipoolCreated(address indexed _minipoolAddress, address indexed _nodeAddress);\n    event MinipoolDestroyed(address indexed _minipoolAddress, address indexed _nodeAddress);\n    event WarningNoMiniPoolsToHarvest();\n    event WarningMinipoolNotStaking(address indexed _minipoolAddress, MinipoolStatus indexed _status);\n\n    using Math for uint256;\n\n    // The total amount of Ether (ETH) funded or allocated by the contract.\n    // This variable keeps track of the ETH resources managed within this contract,\n    uint256 public fundedEth;\n\n    // The total amount of Rocket Pool tokens (RPL) funded or allocated by the contract.\n    // This field is used to track the RPL token balance managed by the contract,\n    uint256 public fundedRpl;\n\n    address[] public minipoolAddresses;\n\n    uint256 public nextMinipoolHavestIndex;\n    uint256 public targetStakeRatio;\n\n    uint256 public numMinipoolsProcessedPerInterval;\n\n    uint256 public requiredLEBStaked;\n\n    mapping(address => uint256) public minipoolIndexMap;\n    mapping(address => uint256) public minipoolAmountFundedEth;\n    mapping(address => uint256) public minipoolAmountFundedRpl;\n\n    mapping(address => address[]) public nodeOperatorOwnedMinipools;\n    mapping(address => uint256) public nodeOperatorEthStaked;\n\n    constructor() initializer {}\n\n    /**\n     * @notice Initializes the contract with the provided storage address.\n     * @dev This function should only be called once, during contract creation or proxy initialization.\n     * It overrides the `initialize` function from a parent contract.\n     * @param _directory The address of the storage contract.\n     */\n    function initialize(address _directory) public override initializer {\n        super.initialize(_directory);\n        targetStakeRatio = 1.5e18; // 150%\n        numMinipoolsProcessedPerInterval = 1;\n\n        // defaulting these to 8eth to only allow LEB8 minipools\n        requiredLEBStaked = 8 ether;\n    }\n\n    /**\n     * @notice Receives incoming Ether and adds it to the queued balance.\n     * @dev This is the fallback function that is called when Ether is sent directly to the contract.\n     */\n    receive() external payable {\n        address payable dp = _directory.getDepositPoolAddress();\n        console.log('fallback od initial');\n        console.log(address(this).balance);\n\n        if (msg.sender != dp) {\n            (bool success, ) = dp.call{value: msg.value}('');\n            require(success, 'low level call failed in od');\n            FundRouter(dp).sendEthToDistributors();\n        }\n\n        console.log('fallback od final');\n        console.log(address(this).balance);\n    }\n\n    function _rebalanceLiquidity() internal nonReentrant {\n        address payable dp = _directory.getDepositPoolAddress();\n        (bool success, ) = dp.call{value: address(this).balance}('');\n        require(success, 'low level call failed in od');\n        FundRouter(dp).sendEthToDistributors();\n\n        IERC20 rpl = IERC20(_directory.getRPLAddress());\n        SafeERC20.safeTransfer(rpl, dp, rpl.balanceOf(address(this)));\n        FundRouter(dp).sendRplToDistributors();\n    }\n\n    /// @notice Gets the total ETH value locked inside the protocol, including inside of validators, the OperatorDistributor,\n    /// and this contract.\n    /// @dev This function sums up the balance of this contract with the amount of funded ETH across all minipools.\n    /// Ensure that all sources of ETH (like the OperatorDistributor) are properly accounted for in the calculation.\n    /// @return The total amount of Ether locked inside the protocol.\n    function getTvlEth() public view returns (uint) {\n        return address(this).balance + fundedEth;\n    }\n\n    /// @notice Gets the total RPL value locked inside the protocol, including inside of validators, the OperatorDistributor,\n    /// and this contract.\n    /// @dev This function calculates the total RPL by summing up the balance of RPL tokens of this contract\n    /// with the amount of funded RPL across all minipools. It retrieves the RPL token address from the `_directory` contract.\n    /// Ensure that all sources of RPL (like the OperatorDistributor) are accurately accounted for.\n    /// @return The total amount of RPL tokens locked inside the protocol.\n    function getTvlRpl() public view returns (uint) {\n        return RocketTokenRPLInterface(_directory.getRPLAddress()).balanceOf(address(this)) + fundedRpl;\n    }\n\n    /**\n     * @notice Removes a minipool address from the tracked list when a node operator exits.\n     * @dev This function efficiently reorders the minipool addresses array and updates the index map.\n     * It then resets the funded amount of ETH and RPL tokens for the removed minipool.\n     * Should only be called by authorized protocol actors or admin.\n     * @param _address The address of the minipool to be removed.\n     *\n     * Emits a `MinipoolDestroyed` event upon successful removal.\n     */ function removeMinipoolAddress(address _address) public onlyProtocolOrAdmin {\n        uint index = minipoolIndexMap[_address] - 1;\n        require(index < minipoolAddresses.length, 'Address not found.');\n\n        // Move the last address into the spot located by index\n        address lastAddress = minipoolAddresses[minipoolAddresses.length - 1];\n        minipoolAddresses[index] = lastAddress;\n        minipoolIndexMap[lastAddress] = index;\n\n        // Remove the last address\n        minipoolAddresses.pop();\n        delete minipoolIndexMap[_address];\n\n        // Set amount funded to 0 since it's being returned to DP\n        minipoolAmountFundedEth[_address] = 0;\n        minipoolAmountFundedRpl[_address] = 0;\n\n        emit MinipoolDestroyed(_address, IMinipool(_address).getNodeAddress());\n    }\n\n    /**\n     * @notice Removes a node operator and all associated minipools.\n     * @dev Iterates through all minipools owned by the node operator and removes them.\n     * This action cannot be reversed, so it should be executed with caution.\n     * Only authorized protocol actors or admin can call this function.\n     * @param _address The address of the node operator to be removed.\n     */\n    function removeNodeOperator(address _address) external onlyProtocolOrAdmin {\n        // remove all minipools owned by node operator\n        address[] memory minipools = nodeOperatorOwnedMinipools[_address];\n        for (uint i = 0; i < minipools.length; i++) {\n            removeMinipoolAddress(minipools[i]);\n        }\n        delete nodeOperatorOwnedMinipools[_address];\n    }\n\n    /**\n     * @notice Stakes the minimum required RPL tokens on behalf of a node.\n     * @dev This function first fetches the node's minimum RPL stake requirement,\n     * approves the Node Staking contract to spend the RPL, and then stakes the RPL for the node.\n     * It assumes that the contract already holds enough RPL tokens for the staking process.\n     * @param _nodeAddress The address of the node for which RPL should be staked.\n     */\n    function _stakeRPLFor(address _nodeAddress) internal {\n        IRocketNodeStaking nodeStaking = IRocketNodeStaking(getDirectory().getRocketNodeStakingAddress());\n        uint256 minimumRplStake = IRocketNodeStaking(getDirectory().getRocketNodeStakingAddress())\n            .getNodeMinimumRPLStake(_nodeAddress);\n\n        fundedRpl += minimumRplStake;\n\n        // approve the node staking contract to spend the RPL\n        RocketTokenRPLInterface rpl = RocketTokenRPLInterface(_directory.getRPLAddress());\n        require(rpl.approve(getDirectory().getRocketNodeStakingAddress(), minimumRplStake));\n\n        // update amount funded rpl\n        minipoolAmountFundedRpl[_nodeAddress] = minimumRplStake;\n\n        nodeStaking.stakeRPLFor(_nodeAddress, minimumRplStake);\n    }\n\n    /**\n     * @notice Prepares a node for minipool creation by setting up necessary staking and validations.\n     * @dev This function first validates the node's withdrawal address, then calculates the required amount of\n     * RPL to stake based on the number of validators associated with the node, and performs a top-up.\n     * Only the protocol or admin can call this function.\n     * @param _NodeAccount The address of the validator account belonging to the Node Operator\n     */\n    function provisionLiquiditiesForMinipoolCreation(\n        address _nodeOperator,\n        address _NodeAccount,\n        uint256 _bond\n    ) external onlyProtocolOrAdmin {\n        _rebalanceLiquidity();\n        require(_bond == requiredLEBStaked, 'OperatorDistributor: Bad _bond amount, should be `requiredLEBStaked`');\n        fundedEth += _bond;\n        nodeOperatorEthStaked[_nodeOperator] += _bond;\n\n        // by default this bonds 150% of stake according to max stake defined here: https://docs.rocketpool.net/guides/node/create-validator#staking-rpl\n        // performTopUp(_NodeAccount, nodeOperatorEthStaked[_nodeOperator]);\n        (bool success, bytes memory data) = _NodeAccount.call{value: _bond}('');\n        if (!success) {\n            revert LowLevelEthTransfer(success, data);\n        }\n    }\n\n    /**\n     * @notice Tops up the node operator's RPL stake if it falls below the target stake ratio.\n     * @dev This function checks the current staking ratio of the node (calculated as ETH staked times its price in RPL\n     * divided by RPL staked). If the ratio is below a predefined target, it calculates the necessary RPL amount to\n     * bring the stake ratio back to the target. Then, the function either stakes the required RPL or stakes\n     * the remaining RPL balance if it's not enough.\n     * @param _NodeAccount The address of the node.\n     * @param _ethStaked The amount of ETH currently staked by the node operator.\n     */\n    function performTopUp(address _NodeAccount, uint256 _ethStaked) public onlyProtocolOrAdmin {\n        uint256 rplStaked = IRocketNodeStaking(_directory.getRocketNodeStakingAddress()).getNodeRPLStake(\n            _NodeAccount\n        );\n        uint256 ethPriceInRpl = PriceFetcher(getDirectory().getPriceFetcherAddress()).getPrice();\n\n        uint256 stakeRatio = rplStaked == 0 ? 1e18 : (_ethStaked * ethPriceInRpl * 1e18) / rplStaked;\n        if (stakeRatio < targetStakeRatio) {\n            uint256 minuend = ((_ethStaked * ethPriceInRpl) / targetStakeRatio);\n            uint256 requiredStakeRpl = minuend < rplStaked ? 0 : minuend - rplStaked;\n            // Make sure the contract has enough RPL to stake\n            uint256 currentRplBalance = RocketTokenRPLInterface(_directory.getRPLAddress()).balanceOf(address(this));\n            if (currentRplBalance >= requiredStakeRpl) {\n                if (requiredStakeRpl == 0) {\n                    return;\n                }\n                // stakeRPLOnBehalfOf\n                // transfer RPL to deposit pool\n                RocketTokenRPLInterface(_directory.getRPLAddress()).transfer(\n                    _directory.getDepositPoolAddress(),\n                    requiredStakeRpl\n                );\n                FundRouter(_directory.getDepositPoolAddress()).stakeRPLFor(_NodeAccount, requiredStakeRpl);\n            } else {\n                if (currentRplBalance == 0) {\n                    return;\n                }\n                // stake what we have\n                RocketTokenRPLInterface(_directory.getRPLAddress()).transfer(\n                    _directory.getDepositPoolAddress(),\n                    currentRplBalance\n                );\n                FundRouter(_directory.getDepositPoolAddress()).stakeRPLFor(_NodeAccount, currentRplBalance);\n            }\n        }\n    }\n\n    function performTopDown(address _nodeAddress, uint256 _ethStaked) public onlyProtocolOrAdmin {\n        uint256 rplStaked = IRocketNodeStaking(_directory.getRocketNodeStakingAddress()).getNodeRPLStake(_nodeAddress);\n        uint256 ethPriceInRpl = PriceFetcher(getDirectory().getPriceFetcherAddress()).getPrice();\n\n        uint256 stakeRatio = rplStaked == 0 ? 1e18 : (_ethStaked * ethPriceInRpl * 1e18) / rplStaked;\n        if (stakeRatio > targetStakeRatio) {\n            uint256 maxRplStake = (_ethStaked * ethPriceInRpl) / targetStakeRatio;\n            uint256 excessRpl = rplStaked > maxRplStake ? rplStaked - maxRplStake : 0;\n\n            if (excessRpl > 0) {\n                fundedRpl -= excessRpl;\n                FundRouter(_directory.getDepositPoolAddress()).unstakeRpl(_nodeAddress, excessRpl);\n\n                // Update the amount of RPL funded by the node\n                minipoolAmountFundedRpl[_nodeAddress] -= excessRpl;\n            }\n        }\n    }\n\n    /**\n     * @notice Calculates the amount of RPL needed to top up the node operator's stake to the target stake ratio.\n     * @dev This view function checks the current staking ratio of the node (calculated as ETH staked times its price in RPL\n     * divided by RPL staked). If the ratio is below a predefined target, it returns the necessary RPL amount to\n     * bring the stake ratio back to the target.\n     * @param _existingRplStake Prior crap staked\n     * @param _ethStaked The amount of ETH currently staked by the node operator.\n     * @return requiredStakeRpl The amount of RPL required to top up to the target stake ratio.\n     */\n    function calculateRequiredRplTopUp(\n        uint256 _existingRplStake,\n        uint256 _ethStaked\n    ) public view returns (uint256 requiredStakeRpl) {\n        console.log('before calling getPriceFetcherAddress');\n        console.logAddress(getDirectory().getPriceFetcherAddress());\n        console.log('B');\n        uint256 ethPriceInRpl = PriceFetcher(getDirectory().getPriceFetcherAddress()).getPrice();\n        console.log('price', ethPriceInRpl);\n        uint256 stakeRatio = _existingRplStake == 0 ? 1e18 : (_ethStaked * ethPriceInRpl * 1e18) / _existingRplStake;\n        if (stakeRatio < targetStakeRatio) {\n            uint256 minuend = ((_ethStaked * ethPriceInRpl) / targetStakeRatio);\n            requiredStakeRpl = minuend < _existingRplStake ? 0 : minuend - _existingRplStake;\n        } else {\n            requiredStakeRpl = 0;\n        }\n        return requiredStakeRpl;\n    }\n\n    /**\n     * @notice Calculates the amount of RPL that can be withdrawn from the node operator's stake without falling below the target stake ratio.\n     * @dev This view function checks the current staking ratio of the node (calculated as ETH staked times its price in RPL\n     * divided by RPL staked). If the ratio is above a predefined target, it returns the maximum RPL amount that can be withdrawn\n     * while still maintaining at least the target stake ratio.\n     * @param _existingRplStake The amount of RPL currently staked by the node operator.\n     * @param _ethStaked The amount of ETH currently staked by the node operator.\n     * @return withdrawableStakeRpl The maximum amount of RPL that can be withdrawn while maintaining the target stake ratio.\n     */\n    function calculateRequiredRplTopDown(\n        uint256 _existingRplStake,\n        uint256 _ethStaked\n    ) public view returns (uint256 withdrawableStakeRpl) {\n        uint256 ethPriceInRpl = PriceFetcher(getDirectory().getPriceFetcherAddress()).getPrice();\n\n        uint256 stakeRatio = _existingRplStake == 0 ? 1e18 : (_ethStaked * ethPriceInRpl * 1e18) / _existingRplStake;\n        if (stakeRatio > targetStakeRatio) {\n            uint256 maxRplStake = (_ethStaked * ethPriceInRpl) / targetStakeRatio;\n            withdrawableStakeRpl = _existingRplStake > maxRplStake ? _existingRplStake - maxRplStake : 0;\n        } else {\n            withdrawableStakeRpl = 0;\n        }\n        return withdrawableStakeRpl;\n    }\n\n    /**\n     * @notice Processes rewards for a predefined number of minipools. This function is meant to be called during\n     * the creation of new intervals. It serves to withdraw rewards from minipools and to top up the RPL stake.\n     * @dev The function first checks if there are any minipools to process. If there aren't, it emits a warning event\n     * and exits. Otherwise, it calls the internal function _processNextMinipool() for a certain number of times defined\n     * by numMinipoolsProcessedPerInterval.\n     */\n    function processNextMinipool() external onlyProtocol {\n        if (minipoolAddresses.length == 0) {\n            emit WarningNoMiniPoolsToHarvest();\n            return;\n        }\n\n        for (uint i = 0; i < numMinipoolsProcessedPerInterval; i++) {\n            _processNextMinipool();\n        }\n    }\n\n    function OnMinipoolCreated(address newMinipoolAddress, address nodeAddress, uint256 bond) external {\n        if (!_directory.hasRole(Constants.CORE_PROTOCOL_ROLE, msg.sender)) {\n            revert BadRole(Constants.CORE_PROTOCOL_ROLE, msg.sender);\n        }\n\n        // register minipool with node operator\n        Whitelist whitelist = Whitelist(getDirectory().getWhitelistAddress());\n        whitelist.registerNewValidator(nodeAddress);\n\n        // new minipool owned by node operator\n        nodeOperatorOwnedMinipools[nodeAddress].push(newMinipoolAddress);\n\n        // add minipool to minipoolAddresses\n        minipoolAddresses.push(newMinipoolAddress);\n        minipoolIndexMap[newMinipoolAddress] = minipoolAddresses.length;\n\n        emit MinipoolCreated(newMinipoolAddress, nodeAddress);\n\n        // updated amount funded eth\n        minipoolAmountFundedEth[newMinipoolAddress] = bond;\n    }\n\n    /**\n     * @dev Processes a single minipool by performing RPL top-up and distributing balance if certain conditions are met.\n     */\n    function _processNextMinipool() internal {\n        uint256 index = nextMinipoolHavestIndex % minipoolAddresses.length;\n        IMinipool minipool = IMinipool(minipoolAddresses[index]);\n\n        if (minipool.getStatus() != MinipoolStatus.Staking) {\n            emit WarningMinipoolNotStaking(address(minipool), minipool.getStatus());\n            return;\n        }\n\n        // process top up\n        address nodeAddress = minipool.getNodeAddress();\n\n        uint256 ethStaked = nodeOperatorEthStaked[nodeAddress];\n\n        performTopUp(nodeAddress, ethStaked);\n        performTopDown(nodeAddress, ethStaked);\n\n        nextMinipoolHavestIndex = index + 1;\n\n        uint256 balance = minipool.getNodeDepositBalance();\n        minipool.distributeBalance(balance >= 8 ether);\n    }\n\n    /**\n     * @notice Set the number of minipools to be processed per interval.\n     * @dev This function can only be called by the contract's admin.\n     * Adjusting this parameter allows the admin to control and optimize the load\n     * on the network for each interval, especially in scenarios with a large number of minipools.\n     * @param _numMinipoolsProcessedPerInterval The new number of minipools to process per interval.\n     */\n    function setNumMinipoolsProcessedPerInterval(uint256 _numMinipoolsProcessedPerInterval) external onlyAdmin {\n        numMinipoolsProcessedPerInterval = _numMinipoolsProcessedPerInterval;\n    }\n\n    function setBondRequirements(uint256 _requiredLEBStaked) external onlyAdmin {\n        requiredLEBStaked = _requiredLEBStaked;\n    }\n\n    function onNodeMinipoolDestroy(address _nodeOperator, uint256 _bond) external onlyProtocol {\n        fundedEth -= _bond;\n        nodeOperatorEthStaked[_nodeOperator] -= _bond;\n    }\n\n    /**\n     * @notice Retrieves the list of minipool addresses managed by the contract.\n     * @dev This function provides a way to fetch all the current minipool addresses in memory.\n     * Useful for off-chain services or frontend interfaces that need to display or interact\n     * with the various minipools.\n     * @return A list of addresses corresponding to the minipools.\n     */\n    function getMinipoolAddresses() external view returns (address[] memory) {\n        return minipoolAddresses;\n    }\n\n    function transferWEthToVault(uint256 _amount) external returns (uint256) {\n        address vault = _directory.getWETHVaultAddress();\n        require(msg.sender == vault, 'caller must be vault');\n        address weth = _directory.getWETHAddress();\n\n        // Check if there's enough WETH in the contract\n        uint256 wethBalance = IWETH(weth).balanceOf(address(this));\n        if (wethBalance >= _amount) {\n            IWETH(weth).deposit{value: _amount}();\n            SafeERC20.safeTransfer(IERC20(weth), vault, _amount);\n            return _amount;\n        } else {\n            return 0;\n        }\n    }\n\n    function transferRplToVault(uint256 _amount) external returns (uint256) {\n        address vault = _directory.getRPLVaultAddress();\n        require(msg.sender == vault, 'caller must be vault');\n\n        // Check if there's enough RPL in the contract\n        address rpl = IERC4626Upgradeable(vault).asset();\n        uint256 rplBalance = IERC20(rpl).balanceOf(address(this));\n        if (rplBalance >= _amount) {\n            SafeERC20.safeTransfer(IERC20(rpl), vault, _amount);\n            return _amount;\n        } else {\n            return 0;\n        }\n    }\n}\n","line":76,"range":[2919,2953]},"functionType":3},{"type":23,"sourceReference":{"function":"log","contract":"OperatorDistributor","sourceName":"hardhat/console.sol","sourceContent":"// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}\n","line":197,"range":[6141,6183]}}],"data":"0x"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)
      at processTicksAndRejections (node:internal/process/task_queues:95:5)
      at runNextTicks (node:internal/process/task_queues:64:3)
      at listOnTimeout (node:internal/timers:540:9)
      at processTimers (node:internal/timers:514:7)

  2) Validator Account Factory
       fails - not whitelisted:
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="Transaction reverted: contract call run out of gas and made the transaction revert", method="estimateGas", transaction={"from":"0x1CBd3b2770909D4e10f157cABC84C7264073C9Ec","to":"0x10e38eE9dd4C549b61400Fc19347D00eD3edAfC4","value":{"type":"BigNumber","hex":"0x6f05b59d3b200000"},"accessList":null}, error={"stackTrace":[{"type":2,"address":{"type":"Buffer","data":[16,227,142,233,221,76,84,155,97,64,15,193,147,71,208,14,211,237,175,196]}},{"type":0,"sourceReference":{"function":"<receive>","contract":"OperatorDistributor","sourceName":"contracts/Operator/OperatorDistributor.sol","sourceContent":"// SPDX-License-Identifier: GPL v3\npragma solidity 0.8.17;\n\nimport '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';\n\nimport '../UpgradeableBase.sol';\nimport '../Whitelist/Whitelist.sol';\nimport '../FundRouter.sol';\nimport '../PriceFetcher.sol';\nimport '../Tokens/WETHVault.sol';\n\nimport '../Utils/Constants.sol';\nimport '../Utils/Errors.sol';\n\nimport '../Interfaces/IWETH.sol';\nimport '../Interfaces/RocketPool/IRocketStorage.sol';\nimport '../Interfaces/RocketPool/IMinipool.sol';\nimport '../Interfaces/RocketPool/IRocketNodeManager.sol';\nimport '../Interfaces/RocketPool/IRocketNodeStaking.sol';\n\ncontract OperatorDistributor is UpgradeableBase, Errors {\n    event MinipoolCreated(address indexed _minipoolAddress, address indexed _nodeAddress);\n    event MinipoolDestroyed(address indexed _minipoolAddress, address indexed _nodeAddress);\n    event WarningNoMiniPoolsToHarvest();\n    event WarningMinipoolNotStaking(address indexed _minipoolAddress, MinipoolStatus indexed _status);\n\n    using Math for uint256;\n\n    // The total amount of Ether (ETH) funded or allocated by the contract.\n    // This variable keeps track of the ETH resources managed within this contract,\n    uint256 public fundedEth;\n\n    // The total amount of Rocket Pool tokens (RPL) funded or allocated by the contract.\n    // This field is used to track the RPL token balance managed by the contract,\n    uint256 public fundedRpl;\n\n    address[] public minipoolAddresses;\n\n    uint256 public nextMinipoolHavestIndex;\n    uint256 public targetStakeRatio;\n\n    uint256 public numMinipoolsProcessedPerInterval;\n\n    uint256 public requiredLEBStaked;\n\n    mapping(address => uint256) public minipoolIndexMap;\n    mapping(address => uint256) public minipoolAmountFundedEth;\n    mapping(address => uint256) public minipoolAmountFundedRpl;\n\n    mapping(address => address[]) public nodeOperatorOwnedMinipools;\n    mapping(address => uint256) public nodeOperatorEthStaked;\n\n    constructor() initializer {}\n\n    /**\n     * @notice Initializes the contract with the provided storage address.\n     * @dev This function should only be called once, during contract creation or proxy initialization.\n     * It overrides the `initialize` function from a parent contract.\n     * @param _directory The address of the storage contract.\n     */\n    function initialize(address _directory) public override initializer {\n        super.initialize(_directory);\n        targetStakeRatio = 1.5e18; // 150%\n        numMinipoolsProcessedPerInterval = 1;\n\n        // defaulting these to 8eth to only allow LEB8 minipools\n        requiredLEBStaked = 8 ether;\n    }\n\n    /**\n     * @notice Receives incoming Ether and adds it to the queued balance.\n     * @dev This is the fallback function that is called when Ether is sent directly to the contract.\n     */\n    receive() external payable {\n        address payable dp = _directory.getDepositPoolAddress();\n        console.log('fallback od initial');\n        console.log(address(this).balance);\n\n        if (msg.sender != dp) {\n            (bool success, ) = dp.call{value: msg.value}('');\n            require(success, 'low level call failed in od');\n            FundRouter(dp).sendEthToDistributors();\n        }\n\n        console.log('fallback od final');\n        console.log(address(this).balance);\n    }\n\n    function _rebalanceLiquidity() internal nonReentrant {\n        address payable dp = _directory.getDepositPoolAddress();\n        (bool success, ) = dp.call{value: address(this).balance}('');\n        require(success, 'low level call failed in od');\n        FundRouter(dp).sendEthToDistributors();\n\n        IERC20 rpl = IERC20(_directory.getRPLAddress());\n        SafeERC20.safeTransfer(rpl, dp, rpl.balanceOf(address(this)));\n        FundRouter(dp).sendRplToDistributors();\n    }\n\n    /// @notice Gets the total ETH value locked inside the protocol, including inside of validators, the OperatorDistributor,\n    /// and this contract.\n    /// @dev This function sums up the balance of this contract with the amount of funded ETH across all minipools.\n    /// Ensure that all sources of ETH (like the OperatorDistributor) are properly accounted for in the calculation.\n    /// @return The total amount of Ether locked inside the protocol.\n    function getTvlEth() public view returns (uint) {\n        return address(this).balance + fundedEth;\n    }\n\n    /// @notice Gets the total RPL value locked inside the protocol, including inside of validators, the OperatorDistributor,\n    /// and this contract.\n    /// @dev This function calculates the total RPL by summing up the balance of RPL tokens of this contract\n    /// with the amount of funded RPL across all minipools. It retrieves the RPL token address from the `_directory` contract.\n    /// Ensure that all sources of RPL (like the OperatorDistributor) are accurately accounted for.\n    /// @return The total amount of RPL tokens locked inside the protocol.\n    function getTvlRpl() public view returns (uint) {\n        return RocketTokenRPLInterface(_directory.getRPLAddress()).balanceOf(address(this)) + fundedRpl;\n    }\n\n    /**\n     * @notice Removes a minipool address from the tracked list when a node operator exits.\n     * @dev This function efficiently reorders the minipool addresses array and updates the index map.\n     * It then resets the funded amount of ETH and RPL tokens for the removed minipool.\n     * Should only be called by authorized protocol actors or admin.\n     * @param _address The address of the minipool to be removed.\n     *\n     * Emits a `MinipoolDestroyed` event upon successful removal.\n     */ function removeMinipoolAddress(address _address) public onlyProtocolOrAdmin {\n        uint index = minipoolIndexMap[_address] - 1;\n        require(index < minipoolAddresses.length, 'Address not found.');\n\n        // Move the last address into the spot located by index\n        address lastAddress = minipoolAddresses[minipoolAddresses.length - 1];\n        minipoolAddresses[index] = lastAddress;\n        minipoolIndexMap[lastAddress] = index;\n\n        // Remove the last address\n        minipoolAddresses.pop();\n        delete minipoolIndexMap[_address];\n\n        // Set amount funded to 0 since it's being returned to DP\n        minipoolAmountFundedEth[_address] = 0;\n        minipoolAmountFundedRpl[_address] = 0;\n\n        emit MinipoolDestroyed(_address, IMinipool(_address).getNodeAddress());\n    }\n\n    /**\n     * @notice Removes a node operator and all associated minipools.\n     * @dev Iterates through all minipools owned by the node operator and removes them.\n     * This action cannot be reversed, so it should be executed with caution.\n     * Only authorized protocol actors or admin can call this function.\n     * @param _address The address of the node operator to be removed.\n     */\n    function removeNodeOperator(address _address) external onlyProtocolOrAdmin {\n        // remove all minipools owned by node operator\n        address[] memory minipools = nodeOperatorOwnedMinipools[_address];\n        for (uint i = 0; i < minipools.length; i++) {\n            removeMinipoolAddress(minipools[i]);\n        }\n        delete nodeOperatorOwnedMinipools[_address];\n    }\n\n    /**\n     * @notice Stakes the minimum required RPL tokens on behalf of a node.\n     * @dev This function first fetches the node's minimum RPL stake requirement,\n     * approves the Node Staking contract to spend the RPL, and then stakes the RPL for the node.\n     * It assumes that the contract already holds enough RPL tokens for the staking process.\n     * @param _nodeAddress The address of the node for which RPL should be staked.\n     */\n    function _stakeRPLFor(address _nodeAddress) internal {\n        IRocketNodeStaking nodeStaking = IRocketNodeStaking(getDirectory().getRocketNodeStakingAddress());\n        uint256 minimumRplStake = IRocketNodeStaking(getDirectory().getRocketNodeStakingAddress())\n            .getNodeMinimumRPLStake(_nodeAddress);\n\n        fundedRpl += minimumRplStake;\n\n        // approve the node staking contract to spend the RPL\n        RocketTokenRPLInterface rpl = RocketTokenRPLInterface(_directory.getRPLAddress());\n        require(rpl.approve(getDirectory().getRocketNodeStakingAddress(), minimumRplStake));\n\n        // update amount funded rpl\n        minipoolAmountFundedRpl[_nodeAddress] = minimumRplStake;\n\n        nodeStaking.stakeRPLFor(_nodeAddress, minimumRplStake);\n    }\n\n    /**\n     * @notice Prepares a node for minipool creation by setting up necessary staking and validations.\n     * @dev This function first validates the node's withdrawal address, then calculates the required amount of\n     * RPL to stake based on the number of validators associated with the node, and performs a top-up.\n     * Only the protocol or admin can call this function.\n     * @param _NodeAccount The address of the validator account belonging to the Node Operator\n     */\n    function provisionLiquiditiesForMinipoolCreation(\n        address _nodeOperator,\n        address _NodeAccount,\n        uint256 _bond\n    ) external onlyProtocolOrAdmin {\n        _rebalanceLiquidity();\n        require(_bond == requiredLEBStaked, 'OperatorDistributor: Bad _bond amount, should be `requiredLEBStaked`');\n        fundedEth += _bond;\n        nodeOperatorEthStaked[_nodeOperator] += _bond;\n\n        // by default this bonds 150% of stake according to max stake defined here: https://docs.rocketpool.net/guides/node/create-validator#staking-rpl\n        // performTopUp(_NodeAccount, nodeOperatorEthStaked[_nodeOperator]);\n        (bool success, bytes memory data) = _NodeAccount.call{value: _bond}('');\n        if (!success) {\n            revert LowLevelEthTransfer(success, data);\n        }\n    }\n\n    /**\n     * @notice Tops up the node operator's RPL stake if it falls below the target stake ratio.\n     * @dev This function checks the current staking ratio of the node (calculated as ETH staked times its price in RPL\n     * divided by RPL staked). If the ratio is below a predefined target, it calculates the necessary RPL amount to\n     * bring the stake ratio back to the target. Then, the function either stakes the required RPL or stakes\n     * the remaining RPL balance if it's not enough.\n     * @param _NodeAccount The address of the node.\n     * @param _ethStaked The amount of ETH currently staked by the node operator.\n     */\n    function performTopUp(address _NodeAccount, uint256 _ethStaked) public onlyProtocolOrAdmin {\n        uint256 rplStaked = IRocketNodeStaking(_directory.getRocketNodeStakingAddress()).getNodeRPLStake(\n            _NodeAccount\n        );\n        uint256 ethPriceInRpl = PriceFetcher(getDirectory().getPriceFetcherAddress()).getPrice();\n\n        uint256 stakeRatio = rplStaked == 0 ? 1e18 : (_ethStaked * ethPriceInRpl * 1e18) / rplStaked;\n        if (stakeRatio < targetStakeRatio) {\n            uint256 minuend = ((_ethStaked * ethPriceInRpl) / targetStakeRatio);\n            uint256 requiredStakeRpl = minuend < rplStaked ? 0 : minuend - rplStaked;\n            // Make sure the contract has enough RPL to stake\n            uint256 currentRplBalance = RocketTokenRPLInterface(_directory.getRPLAddress()).balanceOf(address(this));\n            if (currentRplBalance >= requiredStakeRpl) {\n                if (requiredStakeRpl == 0) {\n                    return;\n                }\n                // stakeRPLOnBehalfOf\n                // transfer RPL to deposit pool\n                RocketTokenRPLInterface(_directory.getRPLAddress()).transfer(\n                    _directory.getDepositPoolAddress(),\n                    requiredStakeRpl\n                );\n                FundRouter(_directory.getDepositPoolAddress()).stakeRPLFor(_NodeAccount, requiredStakeRpl);\n            } else {\n                if (currentRplBalance == 0) {\n                    return;\n                }\n                // stake what we have\n                RocketTokenRPLInterface(_directory.getRPLAddress()).transfer(\n                    _directory.getDepositPoolAddress(),\n                    currentRplBalance\n                );\n                FundRouter(_directory.getDepositPoolAddress()).stakeRPLFor(_NodeAccount, currentRplBalance);\n            }\n        }\n    }\n\n    function performTopDown(address _nodeAddress, uint256 _ethStaked) public onlyProtocolOrAdmin {\n        uint256 rplStaked = IRocketNodeStaking(_directory.getRocketNodeStakingAddress()).getNodeRPLStake(_nodeAddress);\n        uint256 ethPriceInRpl = PriceFetcher(getDirectory().getPriceFetcherAddress()).getPrice();\n\n        uint256 stakeRatio = rplStaked == 0 ? 1e18 : (_ethStaked * ethPriceInRpl * 1e18) / rplStaked;\n        if (stakeRatio > targetStakeRatio) {\n            uint256 maxRplStake = (_ethStaked * ethPriceInRpl) / targetStakeRatio;\n            uint256 excessRpl = rplStaked > maxRplStake ? rplStaked - maxRplStake : 0;\n\n            if (excessRpl > 0) {\n                fundedRpl -= excessRpl;\n                FundRouter(_directory.getDepositPoolAddress()).unstakeRpl(_nodeAddress, excessRpl);\n\n                // Update the amount of RPL funded by the node\n                minipoolAmountFundedRpl[_nodeAddress] -= excessRpl;\n            }\n        }\n    }\n\n    /**\n     * @notice Calculates the amount of RPL needed to top up the node operator's stake to the target stake ratio.\n     * @dev This view function checks the current staking ratio of the node (calculated as ETH staked times its price in RPL\n     * divided by RPL staked). If the ratio is below a predefined target, it returns the necessary RPL amount to\n     * bring the stake ratio back to the target.\n     * @param _existingRplStake Prior crap staked\n     * @param _ethStaked The amount of ETH currently staked by the node operator.\n     * @return requiredStakeRpl The amount of RPL required to top up to the target stake ratio.\n     */\n    function calculateRequiredRplTopUp(\n        uint256 _existingRplStake,\n        uint256 _ethStaked\n    ) public view returns (uint256 requiredStakeRpl) {\n        console.log('before calling getPriceFetcherAddress');\n        console.logAddress(getDirectory().getPriceFetcherAddress());\n        console.log('B');\n        uint256 ethPriceInRpl = PriceFetcher(getDirectory().getPriceFetcherAddress()).getPrice();\n        console.log('price', ethPriceInRpl);\n        uint256 stakeRatio = _existingRplStake == 0 ? 1e18 : (_ethStaked * ethPriceInRpl * 1e18) / _existingRplStake;\n        if (stakeRatio < targetStakeRatio) {\n            uint256 minuend = ((_ethStaked * ethPriceInRpl) / targetStakeRatio);\n            requiredStakeRpl = minuend < _existingRplStake ? 0 : minuend - _existingRplStake;\n        } else {\n            requiredStakeRpl = 0;\n        }\n        return requiredStakeRpl;\n    }\n\n    /**\n     * @notice Calculates the amount of RPL that can be withdrawn from the node operator's stake without falling below the target stake ratio.\n     * @dev This view function checks the current staking ratio of the node (calculated as ETH staked times its price in RPL\n     * divided by RPL staked). If the ratio is above a predefined target, it returns the maximum RPL amount that can be withdrawn\n     * while still maintaining at least the target stake ratio.\n     * @param _existingRplStake The amount of RPL currently staked by the node operator.\n     * @param _ethStaked The amount of ETH currently staked by the node operator.\n     * @return withdrawableStakeRpl The maximum amount of RPL that can be withdrawn while maintaining the target stake ratio.\n     */\n    function calculateRequiredRplTopDown(\n        uint256 _existingRplStake,\n        uint256 _ethStaked\n    ) public view returns (uint256 withdrawableStakeRpl) {\n        uint256 ethPriceInRpl = PriceFetcher(getDirectory().getPriceFetcherAddress()).getPrice();\n\n        uint256 stakeRatio = _existingRplStake == 0 ? 1e18 : (_ethStaked * ethPriceInRpl * 1e18) / _existingRplStake;\n        if (stakeRatio > targetStakeRatio) {\n            uint256 maxRplStake = (_ethStaked * ethPriceInRpl) / targetStakeRatio;\n            withdrawableStakeRpl = _existingRplStake > maxRplStake ? _existingRplStake - maxRplStake : 0;\n        } else {\n            withdrawableStakeRpl = 0;\n        }\n        return withdrawableStakeRpl;\n    }\n\n    /**\n     * @notice Processes rewards for a predefined number of minipools. This function is meant to be called during\n     * the creation of new intervals. It serves to withdraw rewards from minipools and to top up the RPL stake.\n     * @dev The function first checks if there are any minipools to process. If there aren't, it emits a warning event\n     * and exits. Otherwise, it calls the internal function _processNextMinipool() for a certain number of times defined\n     * by numMinipoolsProcessedPerInterval.\n     */\n    function processNextMinipool() external onlyProtocol {\n        if (minipoolAddresses.length == 0) {\n            emit WarningNoMiniPoolsToHarvest();\n            return;\n        }\n\n        for (uint i = 0; i < numMinipoolsProcessedPerInterval; i++) {\n            _processNextMinipool();\n        }\n    }\n\n    function OnMinipoolCreated(address newMinipoolAddress, address nodeAddress, uint256 bond) external {\n        if (!_directory.hasRole(Constants.CORE_PROTOCOL_ROLE, msg.sender)) {\n            revert BadRole(Constants.CORE_PROTOCOL_ROLE, msg.sender);\n        }\n\n        // register minipool with node operator\n        Whitelist whitelist = Whitelist(getDirectory().getWhitelistAddress());\n        whitelist.registerNewValidator(nodeAddress);\n\n        // new minipool owned by node operator\n        nodeOperatorOwnedMinipools[nodeAddress].push(newMinipoolAddress);\n\n        // add minipool to minipoolAddresses\n        minipoolAddresses.push(newMinipoolAddress);\n        minipoolIndexMap[newMinipoolAddress] = minipoolAddresses.length;\n\n        emit MinipoolCreated(newMinipoolAddress, nodeAddress);\n\n        // updated amount funded eth\n        minipoolAmountFundedEth[newMinipoolAddress] = bond;\n    }\n\n    /**\n     * @dev Processes a single minipool by performing RPL top-up and distributing balance if certain conditions are met.\n     */\n    function _processNextMinipool() internal {\n        uint256 index = nextMinipoolHavestIndex % minipoolAddresses.length;\n        IMinipool minipool = IMinipool(minipoolAddresses[index]);\n\n        if (minipool.getStatus() != MinipoolStatus.Staking) {\n            emit WarningMinipoolNotStaking(address(minipool), minipool.getStatus());\n            return;\n        }\n\n        // process top up\n        address nodeAddress = minipool.getNodeAddress();\n\n        uint256 ethStaked = nodeOperatorEthStaked[nodeAddress];\n\n        performTopUp(nodeAddress, ethStaked);\n        performTopDown(nodeAddress, ethStaked);\n\n        nextMinipoolHavestIndex = index + 1;\n\n        uint256 balance = minipool.getNodeDepositBalance();\n        minipool.distributeBalance(balance >= 8 ether);\n    }\n\n    /**\n     * @notice Set the number of minipools to be processed per interval.\n     * @dev This function can only be called by the contract's admin.\n     * Adjusting this parameter allows the admin to control and optimize the load\n     * on the network for each interval, especially in scenarios with a large number of minipools.\n     * @param _numMinipoolsProcessedPerInterval The new number of minipools to process per interval.\n     */\n    function setNumMinipoolsProcessedPerInterval(uint256 _numMinipoolsProcessedPerInterval) external onlyAdmin {\n        numMinipoolsProcessedPerInterval = _numMinipoolsProcessedPerInterval;\n    }\n\n    function setBondRequirements(uint256 _requiredLEBStaked) external onlyAdmin {\n        requiredLEBStaked = _requiredLEBStaked;\n    }\n\n    function onNodeMinipoolDestroy(address _nodeOperator, uint256 _bond) external onlyProtocol {\n        fundedEth -= _bond;\n        nodeOperatorEthStaked[_nodeOperator] -= _bond;\n    }\n\n    /**\n     * @notice Retrieves the list of minipool addresses managed by the contract.\n     * @dev This function provides a way to fetch all the current minipool addresses in memory.\n     * Useful for off-chain services or frontend interfaces that need to display or interact\n     * with the various minipools.\n     * @return A list of addresses corresponding to the minipools.\n     */\n    function getMinipoolAddresses() external view returns (address[] memory) {\n        return minipoolAddresses;\n    }\n\n    function transferWEthToVault(uint256 _amount) external returns (uint256) {\n        address vault = _directory.getWETHVaultAddress();\n        require(msg.sender == vault, 'caller must be vault');\n        address weth = _directory.getWETHAddress();\n\n        // Check if there's enough WETH in the contract\n        uint256 wethBalance = IWETH(weth).balanceOf(address(this));\n        if (wethBalance >= _amount) {\n            IWETH(weth).deposit{value: _amount}();\n            SafeERC20.safeTransfer(IERC20(weth), vault, _amount);\n            return _amount;\n        } else {\n            return 0;\n        }\n    }\n\n    function transferRplToVault(uint256 _amount) external returns (uint256) {\n        address vault = _directory.getRPLVaultAddress();\n        require(msg.sender == vault, 'caller must be vault');\n\n        // Check if there's enough RPL in the contract\n        address rpl = IERC4626Upgradeable(vault).asset();\n        uint256 rplBalance = IERC20(rpl).balanceOf(address(this));\n        if (rplBalance >= _amount) {\n            SafeERC20.safeTransfer(IERC20(rpl), vault, _amount);\n            return _amount;\n        } else {\n            return 0;\n        }\n    }\n}\n","line":82,"range":[3167,3206]},"functionType":3},{"type":2,"address":{"type":"Buffer","data":[38,46,43,80,33,150,32,34,108,95,181,149,100,50,168,143,255,217,75,167]}},{"type":0,"sourceReference":{"function":"sendEthToDistributors","contract":"FundRouter","sourceName":"contracts/FundRouter.sol","sourceContent":"// SPDX-License-Identifier: GPL v3\npragma solidity 0.8.17;\n\nimport '@openzeppelin/contracts/utils/Strings.sol';\n\nimport './UpgradeableBase.sol';\nimport './Operator/OperatorDistributor.sol';\nimport './Operator/NodeSetOperatorRewardDistributor.sol';\nimport './Interfaces/RocketPool/IRocketNodeStaking.sol';\nimport './Tokens/WETHVault.sol';\nimport './Tokens/RPLVault.sol';\n\nimport './Interfaces/IWETH.sol';\nimport './Utils/Constants.sol';\n\n/// @custom:security-contact info@nodeoperator.org\n/// @notice Immutable deposit pool which holds deposits and provides a minimum source of liquidity for depositors.\n/// ETH + RPL intakes from token mints and validator yields and sends to respective ERC4246 vaults.\ncontract FundRouter is UpgradeableBase {\n    constructor() initializer {}\n\n    /// @dev Initializes the FundRouter contract with the specified directory address.\n    /// @param directoryAddress The address of the directory contract.\n    function initialize(address directoryAddress) public virtual override initializer {\n        super.initialize(directoryAddress);\n    }\n\n    ///--------\n    /// GETTERS\n    ///--------\n\n    /// @notice Retrieves the total ETH and WETH value locked inside this deposit pool.\n    /// @dev This function calculates and returns the combined value of ETH and WETH held by the deposit pool.\n    ///      It sums the ETH balance of this contract and the WETH balance from the WETH contract.\n    /// @return The total value in ETH and WETH locked in the deposit pool.\n    function getTvlEth() public view returns (uint) {\n        return address(this).balance + IWETH(_directory.getWETHAddress()).balanceOf(address(this));\n    }\n\n    /// @notice Retrieves the total RPL value locked inside this deposit pool.\n    /// @dev This function calculates and returns the total amount of RPL tokens held by the deposit pool.\n    /// @return The total value in RPL locked in the deposit pool.\n    function getTvlRpl() public view returns (uint) {\n        return RocketTokenRPLInterface(_directory.getRPLAddress()).balanceOf(address(this));\n    }\n\n    ///--------\n    /// ACTIONS\n    ///--------\n\n    /// @notice Unstakes a specified amount of RPL tokens.\n    /// @dev This function allows an administrator to unstake a specified amount of RPL tokens from the Rocket Node Staking contract.\n    /// @param _excessRpl The amount of RPL tokens to unstake.\n    /// @dev The tokens will be withdrawn from the Rocket Node Staking contract.\n    function unstakeRpl(address _nodeAddress, uint256 _excessRpl) external onlyAdmin {\n        IRocketNodeStaking(getDirectory().getRocketNodeStakingAddress()).withdrawRPL(_nodeAddress, _excessRpl);\n    }\n\n    /// @notice Stakes a specified amount of RPL tokens on behalf of a node operator.\n    /// @dev This function allows the protocol or an administrator to stake a specified amount of RPL tokens on behalf of a node operator\n    ///      using the Rocket Node Staking contract.\n    /// @param _nodeAddress The address of the node operator on whose behalf the RPL tokens are being staked.\n    /// @param _amount The amount of RPL tokens to stake.\n    /// @dev This function ensures that the specified amount of RPL tokens is approved and then staked for the given node operator.\n    function stakeRPLFor(address _nodeAddress, uint256 _amount) external onlyProtocolOrAdmin {\n        SafeERC20.safeApprove(\n            RocketTokenRPLInterface(_directory.getRPLAddress()),\n            _directory.getRocketNodeStakingAddress(),\n            0\n        );\n        SafeERC20.safeApprove(\n            RocketTokenRPLInterface(_directory.getRPLAddress()),\n            _directory.getRocketNodeStakingAddress(),\n            _amount\n        );\n        IRocketNodeStaking(_directory.getRocketNodeStakingAddress()).stakeRPLFor(_nodeAddress, _amount);\n    }\n\n    function sendEthToDistributors() public {\n        console.log('sendEthToDistributors.A');\n        // Convert entire WETH balance of this contract to ETH\n        IWETH WETH = IWETH(_directory.getWETHAddress());\n        uint256 wethBalance = WETH.balanceOf(address(this));\n        WETH.withdraw(wethBalance);\n        console.log('sendEthToDistributors.B');\n\n        // Initialize the vault and operator distributor addresses\n        WETHVault vweth = WETHVault(getDirectory().getWETHVaultAddress());\n        address payable operatorDistributor = payable(getDirectory().getOperatorDistributorAddress());\n        console.log('sendEthToDistributors.C');\n\n        // Calculate required capital and total balance\n        uint256 requiredCapital = vweth.getRequiredCollateral();\n        uint256 ethBalance = address(this).balance;\n        console.log('sendEthToDistributors.D');\n\n        if (ethBalance >= requiredCapital) {\n            console.log('sendEthToDistributors.E');\n\n            // Send required capital in WETH to vault and surplus ETH to operator distributor\n            WETH.deposit{value: requiredCapital}();\n            console.log('sendEthToDistributors.E1');\n\n            SafeERC20.safeTransfer(WETH, address(vweth), requiredCapital);\n            console.log('sendEthToDistributors.E2');\n\n            uint256 surplus = ethBalance - requiredCapital;\n            console.log('sendEthToDistributors.E3');\n\n            operatorDistributor.transfer(surplus);\n            console.log('sendEthToDistributors.F');\n        } else {\n            console.log('sendEthToDistributors.G');\n\n            // If not enough ETH balance, convert the shortfall in WETH back to ETH and send it\n            uint256 shortfall = requiredCapital - ethBalance;\n            WETH.deposit{value: shortfall}();\n            SafeERC20.safeTransfer(IERC20(address(WETH)), address(vweth), requiredCapital);\n            console.log('sendEthToDistributors.H');\n        }\n        console.log('sendEthToDistributors.I');\n    }\n\n    function sendRplToDistributors() public {\n        console.log('sendRplToDistributors.A');\n\n        // Initialize the RPLVault and the Operator Distributor addresses\n        RPLVault vrpl = RPLVault(getDirectory().getRPLVaultAddress());\n        address operatorDistributor = getDirectory().getOperatorDistributorAddress();\n        RocketTokenRPLInterface RPL = RocketTokenRPLInterface(_directory.getRPLAddress());\n        console.log('sendRplToDistributors.B');\n\n        // Fetch the required capital in RPL and the total RPL balance of the contract\n        uint256 requiredCapital = vrpl.getRequiredCollateral();\n        uint256 totalBalance = RPL.balanceOf(address(this));\n        console.log('sendRplToDistributors.C');\n\n        // Determine the amount to send to the RPLVault\n        uint256 toRplVault = (totalBalance >= requiredCapital) ? requiredCapital : totalBalance;\n        console.log('sendRplToDistributors.D');\n\n        // Transfer RPL to the RPLVault\n        if (toRplVault > 0) {\n            console.log('sendRplToDistributors.E');\n\n            SafeERC20.safeTransfer(IERC20(address(RPL)), address(vrpl), toRplVault);\n        }\n\n        // Transfer any surplus RPL to the Operator Distributor\n        if (totalBalance > toRplVault) {\n            console.log('sendRplToDistributors.F');\n\n            SafeERC20.safeTransfer(IERC20(address(RPL)), operatorDistributor, totalBalance - toRplVault);\n        }\n        console.log('sendRplToDistributors.G');\n    }\n\n    /// @notice Receive hook for ETH deposits.\n    /// @dev This function allows the contract to receive ETH deposits sent to its address.\n    ///      It is used as a fallback function to accept incoming ETH transfers.\n    receive() external payable {}\n}\n","line":110,"range":[5213,5250]},"functionType":1},{"type":2,"address":{"type":"Buffer","data":[16,227,142,233,221,76,84,155,97,64,15,193,147,71,208,14,211,237,175,196]}},{"type":0,"sourceReference":{"function":"<receive>","contract":"OperatorDistributor","sourceName":"contracts/Operator/OperatorDistributor.sol","sourceContent":"// SPDX-License-Identifier: GPL v3\npragma solidity 0.8.17;\n\nimport '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';\n\nimport '../UpgradeableBase.sol';\nimport '../Whitelist/Whitelist.sol';\nimport '../FundRouter.sol';\nimport '../PriceFetcher.sol';\nimport '../Tokens/WETHVault.sol';\n\nimport '../Utils/Constants.sol';\nimport '../Utils/Errors.sol';\n\nimport '../Interfaces/IWETH.sol';\nimport '../Interfaces/RocketPool/IRocketStorage.sol';\nimport '../Interfaces/RocketPool/IMinipool.sol';\nimport '../Interfaces/RocketPool/IRocketNodeManager.sol';\nimport '../Interfaces/RocketPool/IRocketNodeStaking.sol';\n\ncontract OperatorDistributor is UpgradeableBase, Errors {\n    event MinipoolCreated(address indexed _minipoolAddress, address indexed _nodeAddress);\n    event MinipoolDestroyed(address indexed _minipoolAddress, address indexed _nodeAddress);\n    event WarningNoMiniPoolsToHarvest();\n    event WarningMinipoolNotStaking(address indexed _minipoolAddress, MinipoolStatus indexed _status);\n\n    using Math for uint256;\n\n    // The total amount of Ether (ETH) funded or allocated by the contract.\n    // This variable keeps track of the ETH resources managed within this contract,\n    uint256 public fundedEth;\n\n    // The total amount of Rocket Pool tokens (RPL) funded or allocated by the contract.\n    // This field is used to track the RPL token balance managed by the contract,\n    uint256 public fundedRpl;\n\n    address[] public minipoolAddresses;\n\n    uint256 public nextMinipoolHavestIndex;\n    uint256 public targetStakeRatio;\n\n    uint256 public numMinipoolsProcessedPerInterval;\n\n    uint256 public requiredLEBStaked;\n\n    mapping(address => uint256) public minipoolIndexMap;\n    mapping(address => uint256) public minipoolAmountFundedEth;\n    mapping(address => uint256) public minipoolAmountFundedRpl;\n\n    mapping(address => address[]) public nodeOperatorOwnedMinipools;\n    mapping(address => uint256) public nodeOperatorEthStaked;\n\n    constructor() initializer {}\n\n    /**\n     * @notice Initializes the contract with the provided storage address.\n     * @dev This function should only be called once, during contract creation or proxy initialization.\n     * It overrides the `initialize` function from a parent contract.\n     * @param _directory The address of the storage contract.\n     */\n    function initialize(address _directory) public override initializer {\n        super.initialize(_directory);\n        targetStakeRatio = 1.5e18; // 150%\n        numMinipoolsProcessedPerInterval = 1;\n\n        // defaulting these to 8eth to only allow LEB8 minipools\n        requiredLEBStaked = 8 ether;\n    }\n\n    /**\n     * @notice Receives incoming Ether and adds it to the queued balance.\n     * @dev This is the fallback function that is called when Ether is sent directly to the contract.\n     */\n    receive() external payable {\n        address payable dp = _directory.getDepositPoolAddress();\n        console.log('fallback od initial');\n        console.log(address(this).balance);\n\n        if (msg.sender != dp) {\n            (bool success, ) = dp.call{value: msg.value}('');\n            require(success, 'low level call failed in od');\n            FundRouter(dp).sendEthToDistributors();\n        }\n\n        console.log('fallback od final');\n        console.log(address(this).balance);\n    }\n\n    function _rebalanceLiquidity() internal nonReentrant {\n        address payable dp = _directory.getDepositPoolAddress();\n        (bool success, ) = dp.call{value: address(this).balance}('');\n        require(success, 'low level call failed in od');\n        FundRouter(dp).sendEthToDistributors();\n\n        IERC20 rpl = IERC20(_directory.getRPLAddress());\n        SafeERC20.safeTransfer(rpl, dp, rpl.balanceOf(address(this)));\n        FundRouter(dp).sendRplToDistributors();\n    }\n\n    /// @notice Gets the total ETH value locked inside the protocol, including inside of validators, the OperatorDistributor,\n    /// and this contract.\n    /// @dev This function sums up the balance of this contract with the amount of funded ETH across all minipools.\n    /// Ensure that all sources of ETH (like the OperatorDistributor) are properly accounted for in the calculation.\n    /// @return The total amount of Ether locked inside the protocol.\n    function getTvlEth() public view returns (uint) {\n        return address(this).balance + fundedEth;\n    }\n\n    /// @notice Gets the total RPL value locked inside the protocol, including inside of validators, the OperatorDistributor,\n    /// and this contract.\n    /// @dev This function calculates the total RPL by summing up the balance of RPL tokens of this contract\n    /// with the amount of funded RPL across all minipools. It retrieves the RPL token address from the `_directory` contract.\n    /// Ensure that all sources of RPL (like the OperatorDistributor) are accurately accounted for.\n    /// @return The total amount of RPL tokens locked inside the protocol.\n    function getTvlRpl() public view returns (uint) {\n        return RocketTokenRPLInterface(_directory.getRPLAddress()).balanceOf(address(this)) + fundedRpl;\n    }\n\n    /**\n     * @notice Removes a minipool address from the tracked list when a node operator exits.\n     * @dev This function efficiently reorders the minipool addresses array and updates the index map.\n     * It then resets the funded amount of ETH and RPL tokens for the removed minipool.\n     * Should only be called by authorized protocol actors or admin.\n     * @param _address The address of the minipool to be removed.\n     *\n     * Emits a `MinipoolDestroyed` event upon successful removal.\n     */ function removeMinipoolAddress(address _address) public onlyProtocolOrAdmin {\n        uint index = minipoolIndexMap[_address] - 1;\n        require(index < minipoolAddresses.length, 'Address not found.');\n\n        // Move the last address into the spot located by index\n        address lastAddress = minipoolAddresses[minipoolAddresses.length - 1];\n        minipoolAddresses[index] = lastAddress;\n        minipoolIndexMap[lastAddress] = index;\n\n        // Remove the last address\n        minipoolAddresses.pop();\n        delete minipoolIndexMap[_address];\n\n        // Set amount funded to 0 since it's being returned to DP\n        minipoolAmountFundedEth[_address] = 0;\n        minipoolAmountFundedRpl[_address] = 0;\n\n        emit MinipoolDestroyed(_address, IMinipool(_address).getNodeAddress());\n    }\n\n    /**\n     * @notice Removes a node operator and all associated minipools.\n     * @dev Iterates through all minipools owned by the node operator and removes them.\n     * This action cannot be reversed, so it should be executed with caution.\n     * Only authorized protocol actors or admin can call this function.\n     * @param _address The address of the node operator to be removed.\n     */\n    function removeNodeOperator(address _address) external onlyProtocolOrAdmin {\n        // remove all minipools owned by node operator\n        address[] memory minipools = nodeOperatorOwnedMinipools[_address];\n        for (uint i = 0; i < minipools.length; i++) {\n            removeMinipoolAddress(minipools[i]);\n        }\n        delete nodeOperatorOwnedMinipools[_address];\n    }\n\n    /**\n     * @notice Stakes the minimum required RPL tokens on behalf of a node.\n     * @dev This function first fetches the node's minimum RPL stake requirement,\n     * approves the Node Staking contract to spend the RPL, and then stakes the RPL for the node.\n     * It assumes that the contract already holds enough RPL tokens for the staking process.\n     * @param _nodeAddress The address of the node for which RPL should be staked.\n     */\n    function _stakeRPLFor(address _nodeAddress) internal {\n        IRocketNodeStaking nodeStaking = IRocketNodeStaking(getDirectory().getRocketNodeStakingAddress());\n        uint256 minimumRplStake = IRocketNodeStaking(getDirectory().getRocketNodeStakingAddress())\n            .getNodeMinimumRPLStake(_nodeAddress);\n\n        fundedRpl += minimumRplStake;\n\n        // approve the node staking contract to spend the RPL\n        RocketTokenRPLInterface rpl = RocketTokenRPLInterface(_directory.getRPLAddress());\n        require(rpl.approve(getDirectory().getRocketNodeStakingAddress(), minimumRplStake));\n\n        // update amount funded rpl\n        minipoolAmountFundedRpl[_nodeAddress] = minimumRplStake;\n\n        nodeStaking.stakeRPLFor(_nodeAddress, minimumRplStake);\n    }\n\n    /**\n     * @notice Prepares a node for minipool creation by setting up necessary staking and validations.\n     * @dev This function first validates the node's withdrawal address, then calculates the required amount of\n     * RPL to stake based on the number of validators associated with the node, and performs a top-up.\n     * Only the protocol or admin can call this function.\n     * @param _NodeAccount The address of the validator account belonging to the Node Operator\n     */\n    function provisionLiquiditiesForMinipoolCreation(\n        address _nodeOperator,\n        address _NodeAccount,\n        uint256 _bond\n    ) external onlyProtocolOrAdmin {\n        _rebalanceLiquidity();\n        require(_bond == requiredLEBStaked, 'OperatorDistributor: Bad _bond amount, should be `requiredLEBStaked`');\n        fundedEth += _bond;\n        nodeOperatorEthStaked[_nodeOperator] += _bond;\n\n        // by default this bonds 150% of stake according to max stake defined here: https://docs.rocketpool.net/guides/node/create-validator#staking-rpl\n        // performTopUp(_NodeAccount, nodeOperatorEthStaked[_nodeOperator]);\n        (bool success, bytes memory data) = _NodeAccount.call{value: _bond}('');\n        if (!success) {\n            revert LowLevelEthTransfer(success, data);\n        }\n    }\n\n    /**\n     * @notice Tops up the node operator's RPL stake if it falls below the target stake ratio.\n     * @dev This function checks the current staking ratio of the node (calculated as ETH staked times its price in RPL\n     * divided by RPL staked). If the ratio is below a predefined target, it calculates the necessary RPL amount to\n     * bring the stake ratio back to the target. Then, the function either stakes the required RPL or stakes\n     * the remaining RPL balance if it's not enough.\n     * @param _NodeAccount The address of the node.\n     * @param _ethStaked The amount of ETH currently staked by the node operator.\n     */\n    function performTopUp(address _NodeAccount, uint256 _ethStaked) public onlyProtocolOrAdmin {\n        uint256 rplStaked = IRocketNodeStaking(_directory.getRocketNodeStakingAddress()).getNodeRPLStake(\n            _NodeAccount\n        );\n        uint256 ethPriceInRpl = PriceFetcher(getDirectory().getPriceFetcherAddress()).getPrice();\n\n        uint256 stakeRatio = rplStaked == 0 ? 1e18 : (_ethStaked * ethPriceInRpl * 1e18) / rplStaked;\n        if (stakeRatio < targetStakeRatio) {\n            uint256 minuend = ((_ethStaked * ethPriceInRpl) / targetStakeRatio);\n            uint256 requiredStakeRpl = minuend < rplStaked ? 0 : minuend - rplStaked;\n            // Make sure the contract has enough RPL to stake\n            uint256 currentRplBalance = RocketTokenRPLInterface(_directory.getRPLAddress()).balanceOf(address(this));\n            if (currentRplBalance >= requiredStakeRpl) {\n                if (requiredStakeRpl == 0) {\n                    return;\n                }\n                // stakeRPLOnBehalfOf\n                // transfer RPL to deposit pool\n                RocketTokenRPLInterface(_directory.getRPLAddress()).transfer(\n                    _directory.getDepositPoolAddress(),\n                    requiredStakeRpl\n                );\n                FundRouter(_directory.getDepositPoolAddress()).stakeRPLFor(_NodeAccount, requiredStakeRpl);\n            } else {\n                if (currentRplBalance == 0) {\n                    return;\n                }\n                // stake what we have\n                RocketTokenRPLInterface(_directory.getRPLAddress()).transfer(\n                    _directory.getDepositPoolAddress(),\n                    currentRplBalance\n                );\n                FundRouter(_directory.getDepositPoolAddress()).stakeRPLFor(_NodeAccount, currentRplBalance);\n            }\n        }\n    }\n\n    function performTopDown(address _nodeAddress, uint256 _ethStaked) public onlyProtocolOrAdmin {\n        uint256 rplStaked = IRocketNodeStaking(_directory.getRocketNodeStakingAddress()).getNodeRPLStake(_nodeAddress);\n        uint256 ethPriceInRpl = PriceFetcher(getDirectory().getPriceFetcherAddress()).getPrice();\n\n        uint256 stakeRatio = rplStaked == 0 ? 1e18 : (_ethStaked * ethPriceInRpl * 1e18) / rplStaked;\n        if (stakeRatio > targetStakeRatio) {\n            uint256 maxRplStake = (_ethStaked * ethPriceInRpl) / targetStakeRatio;\n            uint256 excessRpl = rplStaked > maxRplStake ? rplStaked - maxRplStake : 0;\n\n            if (excessRpl > 0) {\n                fundedRpl -= excessRpl;\n                FundRouter(_directory.getDepositPoolAddress()).unstakeRpl(_nodeAddress, excessRpl);\n\n                // Update the amount of RPL funded by the node\n                minipoolAmountFundedRpl[_nodeAddress] -= excessRpl;\n            }\n        }\n    }\n\n    /**\n     * @notice Calculates the amount of RPL needed to top up the node operator's stake to the target stake ratio.\n     * @dev This view function checks the current staking ratio of the node (calculated as ETH staked times its price in RPL\n     * divided by RPL staked). If the ratio is below a predefined target, it returns the necessary RPL amount to\n     * bring the stake ratio back to the target.\n     * @param _existingRplStake Prior crap staked\n     * @param _ethStaked The amount of ETH currently staked by the node operator.\n     * @return requiredStakeRpl The amount of RPL required to top up to the target stake ratio.\n     */\n    function calculateRequiredRplTopUp(\n        uint256 _existingRplStake,\n        uint256 _ethStaked\n    ) public view returns (uint256 requiredStakeRpl) {\n        console.log('before calling getPriceFetcherAddress');\n        console.logAddress(getDirectory().getPriceFetcherAddress());\n        console.log('B');\n        uint256 ethPriceInRpl = PriceFetcher(getDirectory().getPriceFetcherAddress()).getPrice();\n        console.log('price', ethPriceInRpl);\n        uint256 stakeRatio = _existingRplStake == 0 ? 1e18 : (_ethStaked * ethPriceInRpl * 1e18) / _existingRplStake;\n        if (stakeRatio < targetStakeRatio) {\n            uint256 minuend = ((_ethStaked * ethPriceInRpl) / targetStakeRatio);\n            requiredStakeRpl = minuend < _existingRplStake ? 0 : minuend - _existingRplStake;\n        } else {\n            requiredStakeRpl = 0;\n        }\n        return requiredStakeRpl;\n    }\n\n    /**\n     * @notice Calculates the amount of RPL that can be withdrawn from the node operator's stake without falling below the target stake ratio.\n     * @dev This view function checks the current staking ratio of the node (calculated as ETH staked times its price in RPL\n     * divided by RPL staked). If the ratio is above a predefined target, it returns the maximum RPL amount that can be withdrawn\n     * while still maintaining at least the target stake ratio.\n     * @param _existingRplStake The amount of RPL currently staked by the node operator.\n     * @param _ethStaked The amount of ETH currently staked by the node operator.\n     * @return withdrawableStakeRpl The maximum amount of RPL that can be withdrawn while maintaining the target stake ratio.\n     */\n    function calculateRequiredRplTopDown(\n        uint256 _existingRplStake,\n        uint256 _ethStaked\n    ) public view returns (uint256 withdrawableStakeRpl) {\n        uint256 ethPriceInRpl = PriceFetcher(getDirectory().getPriceFetcherAddress()).getPrice();\n\n        uint256 stakeRatio = _existingRplStake == 0 ? 1e18 : (_ethStaked * ethPriceInRpl * 1e18) / _existingRplStake;\n        if (stakeRatio > targetStakeRatio) {\n            uint256 maxRplStake = (_ethStaked * ethPriceInRpl) / targetStakeRatio;\n            withdrawableStakeRpl = _existingRplStake > maxRplStake ? _existingRplStake - maxRplStake : 0;\n        } else {\n            withdrawableStakeRpl = 0;\n        }\n        return withdrawableStakeRpl;\n    }\n\n    /**\n     * @notice Processes rewards for a predefined number of minipools. This function is meant to be called during\n     * the creation of new intervals. It serves to withdraw rewards from minipools and to top up the RPL stake.\n     * @dev The function first checks if there are any minipools to process. If there aren't, it emits a warning event\n     * and exits. Otherwise, it calls the internal function _processNextMinipool() for a certain number of times defined\n     * by numMinipoolsProcessedPerInterval.\n     */\n    function processNextMinipool() external onlyProtocol {\n        if (minipoolAddresses.length == 0) {\n            emit WarningNoMiniPoolsToHarvest();\n            return;\n        }\n\n        for (uint i = 0; i < numMinipoolsProcessedPerInterval; i++) {\n            _processNextMinipool();\n        }\n    }\n\n    function OnMinipoolCreated(address newMinipoolAddress, address nodeAddress, uint256 bond) external {\n        if (!_directory.hasRole(Constants.CORE_PROTOCOL_ROLE, msg.sender)) {\n            revert BadRole(Constants.CORE_PROTOCOL_ROLE, msg.sender);\n        }\n\n        // register minipool with node operator\n        Whitelist whitelist = Whitelist(getDirectory().getWhitelistAddress());\n        whitelist.registerNewValidator(nodeAddress);\n\n        // new minipool owned by node operator\n        nodeOperatorOwnedMinipools[nodeAddress].push(newMinipoolAddress);\n\n        // add minipool to minipoolAddresses\n        minipoolAddresses.push(newMinipoolAddress);\n        minipoolIndexMap[newMinipoolAddress] = minipoolAddresses.length;\n\n        emit MinipoolCreated(newMinipoolAddress, nodeAddress);\n\n        // updated amount funded eth\n        minipoolAmountFundedEth[newMinipoolAddress] = bond;\n    }\n\n    /**\n     * @dev Processes a single minipool by performing RPL top-up and distributing balance if certain conditions are met.\n     */\n    function _processNextMinipool() internal {\n        uint256 index = nextMinipoolHavestIndex % minipoolAddresses.length;\n        IMinipool minipool = IMinipool(minipoolAddresses[index]);\n\n        if (minipool.getStatus() != MinipoolStatus.Staking) {\n            emit WarningMinipoolNotStaking(address(minipool), minipool.getStatus());\n            return;\n        }\n\n        // process top up\n        address nodeAddress = minipool.getNodeAddress();\n\n        uint256 ethStaked = nodeOperatorEthStaked[nodeAddress];\n\n        performTopUp(nodeAddress, ethStaked);\n        performTopDown(nodeAddress, ethStaked);\n\n        nextMinipoolHavestIndex = index + 1;\n\n        uint256 balance = minipool.getNodeDepositBalance();\n        minipool.distributeBalance(balance >= 8 ether);\n    }\n\n    /**\n     * @notice Set the number of minipools to be processed per interval.\n     * @dev This function can only be called by the contract's admin.\n     * Adjusting this parameter allows the admin to control and optimize the load\n     * on the network for each interval, especially in scenarios with a large number of minipools.\n     * @param _numMinipoolsProcessedPerInterval The new number of minipools to process per interval.\n     */\n    function setNumMinipoolsProcessedPerInterval(uint256 _numMinipoolsProcessedPerInterval) external onlyAdmin {\n        numMinipoolsProcessedPerInterval = _numMinipoolsProcessedPerInterval;\n    }\n\n    function setBondRequirements(uint256 _requiredLEBStaked) external onlyAdmin {\n        requiredLEBStaked = _requiredLEBStaked;\n    }\n\n    function onNodeMinipoolDestroy(address _nodeOperator, uint256 _bond) external onlyProtocol {\n        fundedEth -= _bond;\n        nodeOperatorEthStaked[_nodeOperator] -= _bond;\n    }\n\n    /**\n     * @notice Retrieves the list of minipool addresses managed by the contract.\n     * @dev This function provides a way to fetch all the current minipool addresses in memory.\n     * Useful for off-chain services or frontend interfaces that need to display or interact\n     * with the various minipools.\n     * @return A list of addresses corresponding to the minipools.\n     */\n    function getMinipoolAddresses() external view returns (address[] memory) {\n        return minipoolAddresses;\n    }\n\n    function transferWEthToVault(uint256 _amount) external returns (uint256) {\n        address vault = _directory.getWETHVaultAddress();\n        require(msg.sender == vault, 'caller must be vault');\n        address weth = _directory.getWETHAddress();\n\n        // Check if there's enough WETH in the contract\n        uint256 wethBalance = IWETH(weth).balanceOf(address(this));\n        if (wethBalance >= _amount) {\n            IWETH(weth).deposit{value: _amount}();\n            SafeERC20.safeTransfer(IERC20(weth), vault, _amount);\n            return _amount;\n        } else {\n            return 0;\n        }\n    }\n\n    function transferRplToVault(uint256 _amount) external returns (uint256) {\n        address vault = _directory.getRPLVaultAddress();\n        require(msg.sender == vault, 'caller must be vault');\n\n        // Check if there's enough RPL in the contract\n        address rpl = IERC4626Upgradeable(vault).asset();\n        uint256 rplBalance = IERC20(rpl).balanceOf(address(this));\n        if (rplBalance >= _amount) {\n            SafeERC20.safeTransfer(IERC20(rpl), vault, _amount);\n            return _amount;\n        } else {\n            return 0;\n        }\n    }\n}\n","line":76,"range":[2919,2953]},"functionType":3},{"type":23,"sourceReference":{"function":"log","contract":"OperatorDistributor","sourceName":"hardhat/console.sol","sourceContent":"// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}\n","line":197,"range":[6141,6183]}}],"data":"0x"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)
      at processTicksAndRejections (node:internal/process/task_queues:95:5)
      at runNextTicks (node:internal/process/task_queues:64:3)
      at listOnTimeout (node:internal/timers:540:9)
      at processTimers (node:internal/timers:514:7)



